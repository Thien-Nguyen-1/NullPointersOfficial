{
  "version": 3,
  "sources": ["../../node_modules/obscenity/dist/util/Char.js", "../../node_modules/obscenity/dist/censor/BuiltinStrategies.js", "../../node_modules/obscenity/dist/util/Interval.js", "../../node_modules/obscenity/dist/matcher/MatchPayload.js", "../../node_modules/obscenity/dist/censor/TextCensor.js", "../../node_modules/obscenity/dist/matcher/BlacklistedTerm.js", "../../node_modules/obscenity/dist/dataset/DataSet.js", "../../node_modules/obscenity/dist/pattern/Nodes.js", "../../node_modules/obscenity/dist/pattern/Util.js", "../../node_modules/obscenity/dist/transformer/TransformerSet.js", "../../node_modules/obscenity/dist/util/CharacterIterator.js", "../../node_modules/obscenity/dist/matcher/IntervalCollection.js", "../../node_modules/obscenity/dist/matcher/regexp/RegExpMatcher.js", "../../node_modules/obscenity/dist/matcher/Matcher.js", "../../node_modules/obscenity/dist/pattern/ParserError.js", "../../node_modules/obscenity/dist/pattern/Parser.js", "../../node_modules/obscenity/dist/pattern/Pattern.js", "../../node_modules/obscenity/dist/transformer/Transformers.js", "../../node_modules/obscenity/dist/transformer/collapse-duplicates/transformer.js", "../../node_modules/obscenity/dist/transformer/collapse-duplicates/index.js", "../../node_modules/obscenity/dist/transformer/remap-characters/index.js", "../../node_modules/obscenity/dist/transformer/resolve-confusables/confusables.js", "../../node_modules/obscenity/dist/transformer/resolve-confusables/index.js", "../../node_modules/obscenity/dist/transformer/resolve-leetspeak/dictionary.js", "../../node_modules/obscenity/dist/transformer/resolve-leetspeak/index.js", "../../node_modules/obscenity/dist/transformer/to-ascii-lowercase/index.js", "../../node_modules/obscenity/dist/preset/english.js", "../../node_modules/obscenity/dist/transformer/skip-non-alphabetic/index.js", "../../node_modules/obscenity/dist/index.js", "../../node_modules/obscenity/dist/index.mjs"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAndAssertSingleCodePoint = exports.invertCaseOfAlphabeticChar = exports.isUpperCase = exports.isLowerCase = exports.isAlphabetic = exports.isDigit = exports.isWordChar = exports.convertSurrogatePairToCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;\nfunction isHighSurrogate(char) {\n    return 55296 /* CharacterCode.HighSurrogateStart */ <= char && char <= 56319 /* CharacterCode.HighSurrogateEnd */;\n}\nexports.isHighSurrogate = isHighSurrogate;\nfunction isLowSurrogate(char) {\n    return 56320 /* CharacterCode.LowSurrogateStart */ <= char && char <= 57343 /* CharacterCode.LowSurrogateEnd */;\n}\nexports.isLowSurrogate = isLowSurrogate;\n// See https://unicodebook.readthedocs.io/unicode_encodings.html#utf-16-surrogate-pairs.\nfunction convertSurrogatePairToCodePoint(highSurrogate, lowSurrogate) {\n    return ((highSurrogate - 55296 /* CharacterCode.HighSurrogateStart */) * 0x400 +\n        lowSurrogate -\n        56320 /* CharacterCode.LowSurrogateStart */ +\n        0x10000);\n}\nexports.convertSurrogatePairToCodePoint = convertSurrogatePairToCodePoint;\nfunction isWordChar(char) {\n    return isDigit(char) || isAlphabetic(char);\n}\nexports.isWordChar = isWordChar;\nfunction isDigit(char) {\n    return 48 /* CharacterCode.Zero */ <= char && char <= 57 /* CharacterCode.Nine */;\n}\nexports.isDigit = isDigit;\nfunction isAlphabetic(char) {\n    return isLowerCase(char) || isUpperCase(char);\n}\nexports.isAlphabetic = isAlphabetic;\nfunction isLowerCase(char) {\n    return 97 /* CharacterCode.LowerA */ <= char && char <= 122 /* CharacterCode.LowerZ */;\n}\nexports.isLowerCase = isLowerCase;\nfunction isUpperCase(char) {\n    return 65 /* CharacterCode.UpperA */ <= char && char <= 90 /* CharacterCode.UpperZ */;\n}\nexports.isUpperCase = isUpperCase;\n// Input must be a lower-case or upper-case ASCII alphabet character.\nfunction invertCaseOfAlphabeticChar(char) {\n    return char ^ 0x20;\n}\nexports.invertCaseOfAlphabeticChar = invertCaseOfAlphabeticChar;\n// Asserts that the string is comprised of one and only one code point,\n// then returns said code point.\nfunction getAndAssertSingleCodePoint(str) {\n    if ([...str].length !== 1)\n        throw new RangeError(`Expected the input string to be one code point in length.`);\n    return str.codePointAt(0);\n}\nexports.getAndAssertSingleCodePoint = getAndAssertSingleCodePoint;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomCharFromSetCensorStrategy = exports.fixedCharCensorStrategy = exports.fixedPhraseCensorStrategy = exports.grawlixCensorStrategy = exports.asteriskCensorStrategy = exports.keepEndCensorStrategy = exports.keepStartCensorStrategy = void 0;\nconst Char_1 = require(\"../util/Char\");\n/**\n * A text censoring strategy that extends another strategy, adding the first\n * character matched at the start of the generated string.\n *\n * @example\n * ```typescript\n * const strategy = keepStartCensorStrategy(grawlixCensorStrategy());\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'f$@* you'\n * ```\n * @example\n * ```typescript\n * // Since keepEndCensorStrategy() returns another text censoring strategy, you can use it\n * // as the base strategy to pass to keepStartCensorStrategy().\n * const strategy = keepStartCensorStrategy(keepEndCensorStrategy(asteriskCensorStrategy()));\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'f**k you'\n * ```\n * @param baseStrategy - Strategy to extend. It will be used to produce the end of\n * the generated string.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction keepStartCensorStrategy(baseStrategy) {\n    return (ctx) => {\n        if (ctx.overlapsAtStart)\n            return baseStrategy(ctx);\n        const firstChar = String.fromCodePoint(ctx.input.codePointAt(ctx.startIndex));\n        return firstChar + baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 });\n    };\n}\nexports.keepStartCensorStrategy = keepStartCensorStrategy;\n/**\n * A text censoring strategy that extends another strategy, adding the last\n * character matched at the end of the generated string.\n *\n * @example\n * ```typescript\n * const strategy = keepEndCensorStrategy(asteriskCensorStrategy());\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '***k you'\n * ```\n * @param baseStrategy - Strategy to extend. It will be used to produce the start\n * of the generated string.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction keepEndCensorStrategy(baseStrategy) {\n    return (ctx) => {\n        if (ctx.overlapsAtEnd)\n            return baseStrategy(ctx);\n        const lastChar = String.fromCodePoint(ctx.input.codePointAt(ctx.endIndex));\n        return baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 }) + lastChar;\n    };\n}\nexports.keepEndCensorStrategy = keepEndCensorStrategy;\n/**\n * A text censoring strategy that generates strings made up of asterisks (`*`).\n *\n * @example\n * ```typescript\n * const strategy = asteriskCensorStrategy();\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '**** you'\n * ```\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction asteriskCensorStrategy() {\n    return fixedCharCensorStrategy('*');\n}\nexports.asteriskCensorStrategy = asteriskCensorStrategy;\n/**\n * A text censoring strategy that generates\n * [grawlix](https://www.merriam-webster.com/words-at-play/grawlix-symbols-swearing-comic-strips),\n * i.e. strings that contain the characters `%`, `@`, `$`, `&`, and `*`.\n *\n * @example\n * ```typescript\n * const strategy = grawlixCensorStrategy();\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '%@&* you'\n * ```\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction grawlixCensorStrategy() {\n    return randomCharFromSetCensorStrategy('%@$&*');\n}\nexports.grawlixCensorStrategy = grawlixCensorStrategy;\n/**\n * A text censoring strategy that returns a fixed string.\n *\n * @example\n * ```typescript\n * // The replacement phrase '' effectively removes all matched regions\n * // from the string.\n * const strategy = fixedPhraseCensorStrategy('');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: ' you'\n * ```\n * @example\n * ```typescript\n * const strategy = fixedPhraseCensorStrategy('fudge');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'fudge you'\n * ```\n * @param phrase - Replacement phrase to use.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction fixedPhraseCensorStrategy(phrase) {\n    return () => phrase;\n}\nexports.fixedPhraseCensorStrategy = fixedPhraseCensorStrategy;\n/**\n * A text censoring strategy that generates replacement strings that are made up\n * of the character given, repeated as many times as needed.\n *\n * @example\n * ```typescript\n * const strategy = fixedCharCensorStrategy('*');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '**** you'.\n * ```\n * @param char - String that represents the code point which should be used when\n * generating the replacement string. Must be exactly one code point in length.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction fixedCharCensorStrategy(char) {\n    // Make sure the input character is one code point in length.\n    (0, Char_1.getAndAssertSingleCodePoint)(char);\n    return (ctx) => char.repeat(ctx.matchLength);\n}\nexports.fixedCharCensorStrategy = fixedCharCensorStrategy;\n/**\n * A text censoring strategy that generates replacement strings made up of\n * random characters from the set of characters provided. The strings never\n * contain two of the same character in a row.\n *\n * @example\n * ```typescript\n * const strategy = randomCharFromSetCensorStrategy('$#!');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you!'\n * // After: '!#$# you!'\n * ```\n * @param charset - Set of characters from which the replacement string should\n * be constructed. Must have at least two characters.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction randomCharFromSetCensorStrategy(charset) {\n    const chars = [...charset];\n    if (chars.length < 2)\n        throw new Error('The character set passed must have at least 2 characters.');\n    return (ctx) => {\n        if (ctx.matchLength === 0)\n            return '';\n        let lastIdx = Math.floor(Math.random() * chars.length);\n        let censored = chars[lastIdx];\n        for (let i = 1; i < ctx.matchLength; i++) {\n            let idx = Math.floor(Math.random() * (chars.length - 1));\n            // Transform the distribution for idx from [0, len-1) to\n            // [0, lastIdx) âˆª (lastIdx, len) to exclude lastIdx while\n            // ensuring a uniform distribution of generated characters.\n            if (idx >= lastIdx)\n                idx++;\n            lastIdx = idx;\n            censored += chars[idx];\n        }\n        return censored;\n    };\n}\nexports.randomCharFromSetCensorStrategy = randomCharFromSetCensorStrategy;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compareIntervals = void 0;\nfunction compareIntervals(lowerBound0, upperBound0, lowerBound1, upperBound1) {\n    if (lowerBound0 < lowerBound1)\n        return -1;\n    if (lowerBound1 < lowerBound0)\n        return 1;\n    if (upperBound0 < upperBound1)\n        return -1;\n    if (upperBound1 < upperBound0)\n        return 1;\n    return 0;\n}\nexports.compareIntervals = compareIntervals;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compareMatchByPositionAndId = void 0;\nconst Interval_1 = require(\"../util/Interval\");\n/**\n * Compares two match payloads.\n *\n * If the first match payload's start index is less than the second's, `-1` is\n *   returned;\n * If the second match payload's start index is less than the first's, `1` is\n *   returned;\n * If the first match payload's end index is less than the second's, `-1` is\n *   returned;\n * If the second match payload's end index is less than the first's, `1` is\n *   returned;\n * If the first match payload's term ID is less than the second's, `-1` is\n *   returned;\n * If the first match payload's term ID is equal to the second's, `0` is\n *   returned;\n * Otherwise, `1` is returned.\n *\n * @param a - First match payload.\n * @param b - Second match payload.\n * @returns The result of the comparison: -1 if the first should sort lower than\n * the second, 0 if they are the same, and 1 if the second should sort lower\n * than the first.\n */\nfunction compareMatchByPositionAndId(a, b) {\n    const result = (0, Interval_1.compareIntervals)(a.startIndex, a.endIndex, b.startIndex, b.endIndex);\n    if (result !== 0)\n        return result;\n    return a.termId === b.termId ? 0 : a.termId < b.termId ? -1 : 1;\n}\nexports.compareMatchByPositionAndId = compareMatchByPositionAndId;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextCensor = void 0;\nconst MatchPayload_1 = require(\"../matcher/MatchPayload\");\nconst BuiltinStrategies_1 = require(\"./BuiltinStrategies\");\n/**\n * Censors regions of text matched by a [[Matcher]], supporting flexible\n * [[TextCensorStrategy | censoring strategies]].\n */\nclass TextCensor {\n    constructor() {\n        this.strategy = (0, BuiltinStrategies_1.grawlixCensorStrategy)();\n    }\n    /**\n     * Sets the censoring strategy, which is responsible for generating\n     * replacement text for regions of the text that should be censored.\n     *\n     * The default censoring strategy is the [[grawlixCensorStrategy]],\n     * generating text like `$%@*`. There are several other built-in strategies\n     * available:\n     * - [[keepStartCensorStrategy]] - extends another strategy and keeps the\n     *   first character matched, e.g. `f***`.\n     * - [[keepEndCensorStrategy]] - extends another strategy and keeps the last\n     *   character matched, e.g. `***k`.\n     * - [[asteriskCensorStrategy]] - replaces the text with asterisks, e.g.\n     *   `****`.\n     * - [[grawlixCensorStrategy]] - the default strategy, discussed earlier.\n     *\n     * Note that since censoring strategies are just functions (see the\n     * documentation for [[TextCensorStrategy]]), it is relatively simple to\n     * create your own.\n     *\n     * To ease creation of common censoring strategies, we provide a number of\n     * utility functions:\n     * - [[fixedPhraseCensorStrategy]] - generates a fixed phrase, e.g. `fudge`.\n     * - [[fixedCharCensorStrategy]] - generates replacement strings constructed\n     *   from the character given, repeated as many times as needed.\n     * - [[randomCharFromSetCensorStrategy]] - generates replacement strings\n     *   made up of random characters from the set of characters provided.\n     *\n     * @param strategy - Text censoring strategy to use.\n     */\n    setStrategy(strategy) {\n        this.strategy = strategy;\n        return this;\n    }\n    /**\n     * Applies the censoring strategy to the text, returning the censored text.\n     *\n     * **Overlapping regions**\n     *\n     * Overlapping regions are an annoying edge case to deal with when censoring\n     * text. There is no single best way to handle them, but the implementation\n     * of this method guarantees that overlapping regions will always be\n     * replaced, following the rules below:\n     *\n     * - Replacement text for matched regions will be generated in the order\n     *   specified by [[compareMatchByPositionAndId]];\n     * - When generating replacements for regions that overlap at the start with\n     *   some other region, the start index of the censor context passed to the\n     *   censoring strategy will be the end index of the first region, plus one.\n     *\n     * @param input - Input text.\n     * @param matches - A list of matches.\n     * @returns The censored text.\n     */\n    applyTo(input, matches) {\n        if (matches.length === 0)\n            return input;\n        const sorted = [...matches].sort(MatchPayload_1.compareMatchByPositionAndId);\n        let censored = '';\n        let lastIndex = 0; // end index of last match, plus one\n        for (let i = 0; i < sorted.length; i++) {\n            const match = sorted[i];\n            if (lastIndex > match.endIndex)\n                continue; // completely contained in the previous span\n            const overlapsAtStart = match.startIndex < lastIndex;\n            // Add the chunk of text between the end of the last match and the\n            // start of the current match.\n            if (!overlapsAtStart)\n                censored += input.slice(lastIndex, match.startIndex);\n            const actualStartIndex = Math.max(lastIndex, match.startIndex);\n            const overlapsAtEnd = i < sorted.length - 1 && // not the last match\n                match.endIndex >= sorted[i + 1].startIndex && // end index of this match and start index of next one overlap\n                match.endIndex < sorted[i + 1].endIndex; // doesn't completely contain next match\n            censored += this.strategy({ ...match, startIndex: actualStartIndex, input, overlapsAtStart, overlapsAtEnd });\n            lastIndex = match.endIndex + 1;\n        }\n        censored += input.slice(lastIndex);\n        return censored;\n    }\n}\nexports.TextCensor = TextCensor;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignIncrementingIds = void 0;\n/**\n * Assigns incrementing IDs to the patterns provided, starting with 0. It is\n * useful if you have a list of patterns to match against but don't care about\n * identifying which pattern matched.\n *\n * @example\n * ```typescript\n * const matcher = new RegExpMatcher({\n *  ...,\n *  blacklistedTerms: assignIncrementingIds([\n *      pattern`f?uck`,\n *      pattern`|shit|`,\n *  ]),\n * });\n * ```\n * @param patterns - List of parsed patterns.\n * @returns A list of blacklisted terms with valid IDs which can then be passed\n * to the [[RegExpMatcher]].\n */\nfunction assignIncrementingIds(patterns) {\n    let currentId = 0;\n    return patterns.map((pattern) => ({ id: currentId++, pattern }));\n}\nexports.assignIncrementingIds = assignIncrementingIds;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PhraseBuilder = exports.DataSet = void 0;\nconst BlacklistedTerm_1 = require(\"../matcher/BlacklistedTerm\");\n/**\n * Holds phrases (groups of patterns and whitelisted terms), optionally\n * associating metadata with them.\n *\n * @typeParam MetadataType - Metadata type for phrases. Note that the metadata\n * type is implicitly nullable.\n */\nclass DataSet {\n    constructor() {\n        this.containers = [];\n        this.patternCount = 0;\n        this.patternIdToPhraseContainer = new Map(); // pattern ID => index of its container\n    }\n    /**\n     * Adds all the phrases from the dataset provided to this one.\n     *\n     * @example\n     * ```typescript\n     * const customDataset = new DataSet().addAll(englishDataset);\n     * ```\n     * @param other - Other dataset.\n     */\n    addAll(other) {\n        for (const container of other.containers)\n            this.registerContainer(container);\n        return this;\n    }\n    /**\n     * Removes phrases that match the predicate given.\n     *\n     * @example\n     * ```typescript\n     * const customDataset = new DataSet<{ originalWord: string }>()\n     * \t.addAll(englishDataset)\n     * \t.removePhrasesIf((phrase) => phrase.metadata.originalWord === 'fuck');\n     * ```\n     * @param predicate - A predicate that determines whether or not a phrase should be removed.\n     * Return `true` to remove, `false` to keep.\n     */\n    removePhrasesIf(predicate) {\n        // Clear the internal state, then gradually rebuild it by adding the\n        // containers that should be kept.\n        this.patternCount = 0;\n        this.patternIdToPhraseContainer.clear();\n        const containers = this.containers.splice(0);\n        for (const container of containers) {\n            const remove = predicate(container);\n            if (!remove)\n                this.registerContainer(container);\n        }\n        return this;\n    }\n    /**\n     * Adds a phrase to this dataset.\n     *\n     * @example\n     * ```typescript\n     * const data = new DataSet<{ originalWord: string }>()\n     * \t.addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fuck' })\n     * \t\t.addPattern(pattern`fuck`)\n     * \t\t.addPattern(pattern`f[?]ck`)\n     * \t\t.addWhitelistedTerm('Afck'))\n     * \t.build();\n     * ```\n     * @param fn - A function that takes a [[PhraseBuilder]], adds\n     * patterns/whitelisted terms/metadata to it, and returns it.\n     */\n    addPhrase(fn) {\n        const container = fn(new PhraseBuilder()).build();\n        this.registerContainer(container);\n        return this;\n    }\n    /**\n     * Retrieves the phrase metadata associated with a pattern and returns a\n     * copy of the match payload with said metadata attached to it.\n     *\n     * @example\n     * ```typescript\n     * const matches = matcher.getAllMatches(input);\n     * const matchesWithPhraseMetadata = matches.map((match) => dataset.getPayloadWithPhraseMetadata(match));\n     * // Now we can access the 'phraseMetadata' property:\n     * const phraseMetadata = matchesWithPhraseMetadata[0].phraseMetadata;\n     * ```\n     * @param payload - Original match payload.\n     */\n    getPayloadWithPhraseMetadata(payload) {\n        const offset = this.patternIdToPhraseContainer.get(payload.termId);\n        if (offset === undefined) {\n            throw new Error(`The pattern with ID ${payload.termId} does not exist in this dataset.`);\n        }\n        return {\n            ...payload,\n            phraseMetadata: this.containers[offset].metadata,\n        };\n    }\n    /**\n     * Returns the dataset in a format suitable for usage with the [[RegExpMatcher]].\n     *\n     * @example\n     * ```typescript\n     * // With the RegExpMatcher:\n     * const matcher = new RegExpMatcher({\n     * \t...dataset.build(),\n     * \t// additional options here\n     * });\n     * ```\n     */\n    build() {\n        return {\n            blacklistedTerms: (0, BlacklistedTerm_1.assignIncrementingIds)(this.containers.flatMap((p) => p.patterns)),\n            whitelistedTerms: this.containers.flatMap((p) => p.whitelistedTerms),\n        };\n    }\n    registerContainer(container) {\n        const offset = this.containers.push(container) - 1;\n        for (let i = 0, phraseId = this.patternCount; i < container.patterns.length; i++, phraseId++) {\n            this.patternIdToPhraseContainer.set(phraseId, offset);\n            this.patternCount++;\n        }\n    }\n}\nexports.DataSet = DataSet;\n/**\n * Builder for phrases.\n */\nclass PhraseBuilder {\n    constructor() {\n        this.patterns = [];\n        this.whitelistedTerms = [];\n    }\n    /**\n     * Associates a pattern with this phrase.\n     *\n     * @param pattern - Pattern to add.\n     */\n    addPattern(pattern) {\n        this.patterns.push(pattern);\n        return this;\n    }\n    /**\n     * Associates a whitelisted pattern with this phrase.\n     *\n     * @param term - Whitelisted term to add.\n     */\n    addWhitelistedTerm(term) {\n        this.whitelistedTerms.push(term);\n        return this;\n    }\n    /**\n     * Associates some metadata with this phrase.\n     *\n     * @param metadata - Metadata to use.\n     */\n    setMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the phrase, returning a [[PhraseContainer]] for use with the\n     * [[DataSet]].\n     */\n    build() {\n        return {\n            patterns: this.patterns,\n            whitelistedTerms: this.whitelistedTerms,\n            metadata: this.metadata,\n        };\n    }\n}\nexports.PhraseBuilder = PhraseBuilder;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyntaxKind = void 0;\n/**\n * An enumeration of the kinds of nodes there are.\n */\nvar SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"Optional\"] = 0] = \"Optional\";\n    SyntaxKind[SyntaxKind[\"Wildcard\"] = 1] = \"Wildcard\";\n    SyntaxKind[SyntaxKind[\"Literal\"] = 2] = \"Literal\";\n    SyntaxKind[SyntaxKind[\"BoundaryAssertion\"] = 3] = \"BoundaryAssertion\";\n})(SyntaxKind || (exports.SyntaxKind = SyntaxKind = {}));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRegExpStringForNode = exports.compilePatternToRegExp = exports.potentiallyMatchesEmptyString = void 0;\nconst Nodes_1 = require(\"./Nodes\");\nfunction potentiallyMatchesEmptyString(pattern) {\n    return pattern.nodes.every((node) => node.kind === Nodes_1.SyntaxKind.Optional);\n}\nexports.potentiallyMatchesEmptyString = potentiallyMatchesEmptyString;\nfunction compilePatternToRegExp(pattern) {\n    let regExpStr = '';\n    if (pattern.requireWordBoundaryAtStart)\n        regExpStr += '\\\\b';\n    for (const node of pattern.nodes)\n        regExpStr += getRegExpStringForNode(node);\n    if (pattern.requireWordBoundaryAtEnd)\n        regExpStr += `\\\\b`;\n    return new RegExp(regExpStr, 'gs');\n}\nexports.compilePatternToRegExp = compilePatternToRegExp;\nconst regExpSpecialChars = ['[', '.', '*', '+', '?', '^', '$', '{', '}', '(', ')', '|', '[', '\\\\', ']'].map((str) => str.charCodeAt(0));\nfunction getRegExpStringForNode(node) {\n    switch (node.kind) {\n        case Nodes_1.SyntaxKind.Literal: {\n            let str = '';\n            for (const char of node.chars) {\n                if (regExpSpecialChars.includes(char))\n                    str += '\\\\';\n                str += String.fromCodePoint(char);\n            }\n            return str;\n        }\n        case Nodes_1.SyntaxKind.Optional:\n            return `(?:${getRegExpStringForNode(node.childNode)})?`;\n        case Nodes_1.SyntaxKind.Wildcard:\n            return `.`;\n    }\n}\nexports.getRegExpStringForNode = getRegExpStringForNode;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransformerSet = void 0;\nclass TransformerSet {\n    constructor(transformers) {\n        this.transformers = transformers;\n        this.statefulTransformers = Array.from({ length: this.transformers.length });\n        for (let i = 0; i < this.transformers.length; i++) {\n            const transformer = this.transformers[i];\n            if (transformer.type === 1 /* TransformerType.Stateful */) {\n                this.statefulTransformers[i] = transformer.factory();\n            }\n        }\n    }\n    applyTo(char) {\n        let transformed = char;\n        for (let i = 0; i < this.transformers.length && transformed !== undefined; i++) {\n            const transformer = this.transformers[i];\n            if (transformer.type === 0 /* TransformerType.Simple */)\n                transformed = transformer.transform(transformed);\n            else\n                transformed = this.statefulTransformers[i].transform(transformed);\n        }\n        return transformed;\n    }\n    resetAll() {\n        for (let i = 0; i < this.transformers.length; i++) {\n            if (this.transformers[i].type === 1 /* TransformerType.Stateful */) {\n                this.statefulTransformers[i].reset();\n            }\n        }\n    }\n}\nexports.TransformerSet = TransformerSet;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CharacterIterator = void 0;\nconst Char_1 = require(\"./Char\");\nclass CharacterIterator {\n    constructor(input) {\n        this.lastPosition = -1;\n        this.currentPosition = 0;\n        this._lastWidth = 0;\n        this._input = input ?? '';\n    }\n    get input() {\n        return this._input;\n    }\n    setInput(input) {\n        this._input = input;\n        this.reset();\n        return this;\n    }\n    reset() {\n        this.lastPosition = -1;\n        this.currentPosition = 0;\n        this._lastWidth = 0;\n    }\n    next() {\n        if (this.done)\n            return { done: true, value: undefined };\n        this.lastPosition = this.currentPosition;\n        const char = this._input.charCodeAt(this.currentPosition++);\n        this._lastWidth = 1;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.done || !(0, Char_1.isHighSurrogate)(char))\n            return { done: false, value: char };\n        // Do we have a surrogate pair?\n        const next = this._input.charCodeAt(this.currentPosition);\n        if ((0, Char_1.isLowSurrogate)(next)) {\n            this._lastWidth++;\n            this.currentPosition++;\n            return { done: false, value: (0, Char_1.convertSurrogatePairToCodePoint)(char, next) };\n        }\n        return { done: false, value: char };\n    }\n    // Position of the iterator; equals the start index of the last character consumed.\n    // -1 if no characters were consumed yet.\n    get position() {\n        return this.lastPosition;\n    }\n    // Width of the last character consumed; 2 if it was a surrogate pair and 1 otherwise.\n    // 0 if no characters were consumed yet.\n    get lastWidth() {\n        return this._lastWidth;\n    }\n    get done() {\n        return this.currentPosition >= this._input.length;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nexports.CharacterIterator = CharacterIterator;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IntervalCollection = void 0;\nclass IntervalCollection {\n    constructor() {\n        this.dirty = false;\n        this.intervals = [];\n    }\n    insert(lowerBound, upperBound) {\n        this.intervals.push([lowerBound, upperBound]);\n        this.dirty = true;\n    }\n    query(lowerBound, upperBound) {\n        if (this.intervals.length === 0)\n            return false;\n        if (this.dirty) {\n            this.dirty = false;\n            // Sort by lower bound.\n            this.intervals.sort(\n            /* istanbul ignore next: not possible to write a robust test for this */\n            (a, b) => (a[0] < b[0] ? -1 : b[0] < a[0] ? 1 : 0));\n        }\n        for (const interval of this.intervals) {\n            // Since the intervals are sorted by lower bound, if we see an\n            // interval with a lower bound greater than the target, we can skip\n            // checking all the ones after it as it's impossible that they fully\n            // contain the target interval.\n            if (interval[0] > lowerBound)\n                break;\n            if (interval[0] <= lowerBound && upperBound <= interval[1])\n                return true;\n        }\n        return false;\n    }\n    values() {\n        return this.intervals.values();\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n}\nexports.IntervalCollection = IntervalCollection;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegExpMatcher = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Util_1 = require(\"../../pattern/Util\");\nconst TransformerSet_1 = require(\"../../transformer/TransformerSet\");\nconst CharacterIterator_1 = require(\"../../util/CharacterIterator\");\nconst IntervalCollection_1 = require(\"../IntervalCollection\");\nconst MatchPayload_1 = require(\"../MatchPayload\");\n/**\n * An implementation of the [[Matcher]] interface using regular expressions and\n * string searching methods.\n */\nclass RegExpMatcher {\n    /**\n     * Creates a new [[RegExpMatcher]] with the options given.\n     *\n     * @example\n     * ```typescript\n     * // Use the options provided by the English preset.\n     * const matcher = new RegExpMatcher({\n     * \t...englishDataset.build(),\n     * \t...englishRecommendedTransformers,\n     * });\n     * ```\n     * @example\n     * ```typescript\n     * // Simple matcher that only has blacklisted patterns.\n     * const matcher = new RegExpMatcher({\n     *  blacklistedTerms: assignIncrementingIds([\n     *      pattern`fuck`,\n     *      pattern`f?uck`, // wildcards (?)\n     *      pattern`bitch`,\n     *      pattern`b[i]tch` // optionals ([i] matches either \"i\" or \"\")\n     *  ]),\n     * });\n     *\n     * // Check whether some string matches any of the patterns.\n     * const doesMatch = matcher.hasMatch('fuck you bitch');\n     * ```\n     * @example\n     * ```typescript\n     * // A more advanced example, with transformers and whitelisted terms.\n     * const matcher = new RegExpMatcher({\n     *  blacklistedTerms: [\n     *      { id: 1, pattern: pattern`penis` },\n     *      { id: 2, pattern: pattern`fuck` },\n     *  ],\n     *  whitelistedTerms: ['pen is'],\n     *  blacklistMatcherTransformers: [\n     *      resolveConfusablesTransformer(), // 'ðŸ…°' => 'a'\n     *      resolveLeetSpeakTransformer(), // '$' => 's'\n     *      foldAsciiCharCaseTransformer(), // case insensitive matching\n     *      skipNonAlphabeticTransformer(), // 'f.u...c.k' => 'fuck'\n     *      collapseDuplicatesTransformer(), // 'aaaa' => 'a'\n     *  ],\n     * });\n     *\n     * // Output all matches.\n     * console.log(matcher.getAllMatches('fu.....uuuuCK the pen is mightier than the sword!'));\n     * ```\n     * @param options - Options to use.\n     */\n    constructor({ blacklistedTerms, whitelistedTerms = [], blacklistMatcherTransformers = [], whitelistMatcherTransformers = [], }) {\n        this.blacklistedTerms = this.compileTerms(blacklistedTerms);\n        this.validateWhitelistedTerms(whitelistedTerms);\n        this.whitelistedTerms = whitelistedTerms;\n        this.blacklistMatcherTransformers = new TransformerSet_1.TransformerSet(blacklistMatcherTransformers);\n        this.whitelistMatcherTransformers = new TransformerSet_1.TransformerSet(whitelistMatcherTransformers);\n    }\n    getAllMatches(input, sorted = false) {\n        const whitelistedIntervals = this.getWhitelistedIntervals(input);\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.blacklistMatcherTransformers);\n        const matches = [];\n        for (const blacklistedTerm of this.blacklistedTerms) {\n            for (const match of transformed.matchAll(blacklistedTerm.regExp)) {\n                const origStartIndex = transformedToOrigIndex[match.index];\n                let origEndIndex = transformedToOrigIndex[match.index + match[0].length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                if (!whitelistedIntervals.query(origStartIndex, origEndIndex)) {\n                    matches.push({\n                        termId: blacklistedTerm.id,\n                        startIndex: origStartIndex,\n                        endIndex: origEndIndex,\n                        matchLength: [...match[0]].length,\n                    });\n                }\n            }\n        }\n        if (sorted)\n            matches.sort(MatchPayload_1.compareMatchByPositionAndId);\n        return matches;\n    }\n    hasMatch(input) {\n        const whitelistedIntervals = this.getWhitelistedIntervals(input);\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.blacklistMatcherTransformers);\n        for (const blacklistedTerm of this.blacklistedTerms) {\n            for (const match of transformed.matchAll(blacklistedTerm.regExp)) {\n                const origStartIndex = transformedToOrigIndex[match.index];\n                let origEndIndex = transformedToOrigIndex[match.index + match[0].length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                if (!whitelistedIntervals.query(origStartIndex, origEndIndex))\n                    return true;\n            }\n        }\n        return false;\n    }\n    getWhitelistedIntervals(input) {\n        const matches = new IntervalCollection_1.IntervalCollection();\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.whitelistMatcherTransformers);\n        for (const whitelistedTerm of this.whitelistedTerms) {\n            let lastEnd = 0;\n            for (let startIndex = transformed.indexOf(whitelistedTerm, lastEnd); startIndex !== -1; startIndex = transformed.indexOf(whitelistedTerm, lastEnd)) {\n                let origEndIndex = transformedToOrigIndex[startIndex + whitelistedTerm.length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                matches.insert(transformedToOrigIndex[startIndex], origEndIndex);\n                lastEnd = startIndex + whitelistedTerm.length;\n            }\n        }\n        return matches;\n    }\n    applyTransformers(input, transformers) {\n        const transformedToOrigIndex = [];\n        let transformed = '';\n        const iter = new CharacterIterator_1.CharacterIterator(input);\n        for (const char of iter) {\n            const transformedChar = transformers.applyTo(char);\n            if (transformedChar !== undefined) {\n                transformed += String.fromCodePoint(transformedChar);\n                while (transformedToOrigIndex.length < transformed.length)\n                    transformedToOrigIndex.push(iter.position);\n            }\n        }\n        transformers.resetAll();\n        return [transformedToOrigIndex, transformed];\n    }\n    compileTerms(terms) {\n        const compiled = [];\n        const seenIds = new Set();\n        for (const term of terms) {\n            if (seenIds.has(term.id))\n                throw new Error(`Duplicate blacklisted term ID ${term.id}.`);\n            if ((0, Util_1.potentiallyMatchesEmptyString)(term.pattern)) {\n                throw new Error(`Pattern with ID ${term.id} potentially matches empty string; this is unsupported.`);\n            }\n            compiled.push({\n                id: term.id,\n                regExp: (0, Util_1.compilePatternToRegExp)(term.pattern),\n            });\n            seenIds.add(term.id);\n        }\n        return compiled;\n    }\n    validateWhitelistedTerms(whitelist) {\n        if (whitelist.some((term) => term.length === 0)) {\n            throw new Error('Whitelisted term set contains empty string; this is unsupported.');\n        }\n    }\n}\nexports.RegExpMatcher = RegExpMatcher;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserError = void 0;\n/**\n * Custom error thrown by the parser when syntactical errors are detected.\n */\nclass ParserError extends Error {\n    constructor(message, line, column) {\n        super(`${line}:${column}: ${message}`);\n        this.name = 'ParserError';\n        this.line = line;\n        this.column = column;\n    }\n}\nexports.ParserError = ParserError;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst Char_1 = require(\"../util/Char\");\nconst CharacterIterator_1 = require(\"../util/CharacterIterator\");\nconst Nodes_1 = require(\"./Nodes\");\nconst ParserError_1 = require(\"./ParserError\");\nconst supportsEscaping = [\n    92 /* CharacterCode.Backslash */,\n    91 /* CharacterCode.LeftSquareBracket */,\n    93 /* CharacterCode.RightSquareBracket */,\n    63 /* CharacterCode.QuestionMark */,\n    124 /* CharacterCode.VerticalBar */,\n];\nconst supportsEscapingList = supportsEscaping.map((char) => `'${String.fromCodePoint(char)}'`).join(', ');\nconst eof = -1;\nclass Parser {\n    constructor() {\n        this.input = '';\n        this.line = 1;\n        this.column = 1;\n        this.position = 0;\n        this.lastColumn = 1;\n        this.lastWidth = 0;\n    }\n    parse(input) {\n        this.setInput(input);\n        const nodes = [];\n        const firstNode = this.nextNode();\n        const requireWordBoundaryAtStart = firstNode?.kind === Nodes_1.SyntaxKind.BoundaryAssertion;\n        if (firstNode && !requireWordBoundaryAtStart)\n            nodes.push(firstNode);\n        let requireWordBoundaryAtEnd = false;\n        while (!this.done) {\n            const pos = this.mark();\n            const node = this.nextNode();\n            if (node.kind !== Nodes_1.SyntaxKind.BoundaryAssertion) {\n                nodes.push(node);\n                continue;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!this.done) {\n                this.reportError('Boundary assertions are not supported in this position; they are only allowed at the start / end of the pattern.', pos);\n            }\n            requireWordBoundaryAtEnd = true;\n        }\n        return { requireWordBoundaryAtStart, requireWordBoundaryAtEnd, nodes };\n    }\n    setInput(input) {\n        this.input = input;\n        this.line = 1;\n        this.column = 1;\n        this.position = 0;\n        this.lastColumn = 1;\n        this.lastWidth = 0;\n        return this;\n    }\n    nextNode() {\n        switch (this.peek()) {\n            case eof:\n                return undefined;\n            case 91 /* CharacterCode.LeftSquareBracket */:\n                return this.parseOptional();\n            case 93 /* CharacterCode.RightSquareBracket */:\n                this.reportError(`Unexpected ']' with no corresponding '['.`);\n            // eslint-disable-next-line no-fallthrough\n            case 63 /* CharacterCode.QuestionMark */:\n                return this.parseWildcard();\n            case 124 /* CharacterCode.VerticalBar */:\n                return this.parseBoundaryAssertion();\n            default:\n                return this.parseLiteral();\n        }\n    }\n    get done() {\n        return this.position >= this.input.length;\n    }\n    // Optional ::= '[' Wildcard | Text ']'\n    parseOptional() {\n        const preOpenBracketPos = this.mark();\n        this.next(); // '['\n        const postOpenBracketPos = this.mark();\n        if (this.done)\n            this.reportError(\"Unexpected unclosed '['.\", preOpenBracketPos);\n        if (this.accept('['))\n            this.reportError('Unexpected nested optional node.', postOpenBracketPos);\n        const childNode = this.nextNode();\n        if (childNode.kind === Nodes_1.SyntaxKind.BoundaryAssertion) {\n            this.reportError('Boundary assertions are not supported in this position; they are only allowed at the start / end of the pattern.', postOpenBracketPos);\n        }\n        if (!this.accept(']'))\n            this.reportError(\"Unexpected unclosed '['.\");\n        return { kind: Nodes_1.SyntaxKind.Optional, childNode: childNode };\n    }\n    // Wildcard ::= '?'\n    parseWildcard() {\n        this.next(); // '?'\n        return { kind: Nodes_1.SyntaxKind.Wildcard };\n    }\n    // BoundaryAssertion ::= '|'\n    parseBoundaryAssertion() {\n        this.next(); // '|'\n        return { kind: Nodes_1.SyntaxKind.BoundaryAssertion };\n    }\n    // Literal              ::= (NON_SPECIAL | '\\' SUPPORTS_ESCAPING)+\n    // NON_SPECIAL         ::= _any character other than '\\', '?', '[', ']', or '|'_\n    // SUPPORTS_ESCAPING   ::= '\\' | '[' | ']' | '?' | '|'\n    parseLiteral() {\n        const chars = [];\n        while (!this.done) {\n            if (this.accept('[]?|')) {\n                this.backup();\n                break;\n            }\n            const next = this.next();\n            if (next === 92 /* CharacterCode.Backslash */) {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (this.done) {\n                    this.backup();\n                    this.reportError('Unexpected trailing backslash.');\n                }\n                // Can we escape the next character?\n                const escaped = this.next();\n                if (!supportsEscaping.includes(escaped)) {\n                    const repr = String.fromCodePoint(escaped);\n                    this.backup();\n                    this.reportError(`Cannot escape character '${repr}'; the only characters that can be escaped are the following: ${supportsEscapingList}.`);\n                }\n                chars.push(escaped);\n            }\n            else {\n                chars.push(next);\n            }\n        }\n        return { kind: Nodes_1.SyntaxKind.Literal, chars };\n    }\n    reportError(message, { line = this.line, column = this.column } = {}) {\n        throw new ParserError_1.ParserError(message, line, column);\n    }\n    // Marks the current position.\n    mark() {\n        return { line: this.line, column: this.column };\n    }\n    // Accepts any code point in the charset provided. Iff accepted, the character is consumed.\n    accept(charset) {\n        const next = this.next();\n        const iter = new CharacterIterator_1.CharacterIterator(charset);\n        for (const char of iter) {\n            if (char === next)\n                return true;\n        }\n        this.backup();\n        return false;\n    }\n    // Reads one code point from the input, without consuming it.\n    peek() {\n        const next = this.next();\n        this.backup();\n        return next;\n    }\n    // Consumes one code point from the input.\n    next() {\n        if (this.done)\n            return eof;\n        const char = this.input.charCodeAt(this.position++);\n        this.lastWidth = 1;\n        if (char === 10 /* CharacterCode.Newline */) {\n            this.lastColumn = this.column;\n            this.column = 1;\n            this.line++;\n            return char;\n        }\n        this.lastColumn = this.column++;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!(0, Char_1.isHighSurrogate)(char) || this.done)\n            return char;\n        // Do we have a surrogate pair?\n        const next = this.input.charCodeAt(this.position);\n        if ((0, Char_1.isLowSurrogate)(next)) {\n            this.position++;\n            this.lastWidth++;\n            return (0, Char_1.convertSurrogatePairToCodePoint)(char, next);\n        }\n        return char;\n    }\n    // Steps back one character; can only be called once per call to next().\n    backup() {\n        this.position -= this.lastWidth;\n        this.column = this.lastColumn;\n        // Adjust line count if needed.\n        if (this.lastWidth === 1 && this.input.charCodeAt(this.position) === 10 /* CharacterCode.Newline */) {\n            this.line--;\n        }\n    }\n}\nexports.Parser = Parser;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRawPattern = exports.pattern = void 0;\nconst Parser_1 = require(\"./Parser\");\nconst parser = new Parser_1.Parser();\n/**\n * Parses a pattern, which matches a set of strings; see the `Syntax` section\n * for details. This function is intended to be called as a [template\n * tag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).\n *\n * **Syntax**\n *\n * Generally speaking, in patterns, characters are interpreted literally. That\n * is, they match exactly what they are: `a` matches an `a`, `b` matches a `b`,\n * `;` matches a `;`, and so on.\n *\n * However, there are several constructs that have special meaning:\n *\n * - `[expr]` matches either the empty string or `expr` (an **optional\n *   expression**). `expr` may be a sequence of literal characters or a wildcard\n *   (see below).\n * - `?` matches any character (a **wildcard**).\n * - A `|` at the start or end of the pattern asserts position at a word\n *   boundary (a **word boundary assertion**). If `|` is at the start, it\n *   ensures that the match either starts at the start of the string or a non-\n *   word character preceding it; if it is at the end, it ensures that the match\n *   either ends at the end of the string or a non-word character follows it.\n *\n *   A word character is an lower-case or upper-case ASCII alphabet character or\n *   an ASCII digit.\n * - In a literal, a backslash may be used to **escape** one of the\n *   meta-characters mentioned above so that it does match literally: `\\\\[`\n *   matches `[`, and does not mark the start of an optional expression.\n *\n *   **Note about escapes**\n *\n *   As this function operates on raw strings, double-escaping backslashes is\n *   not necessary:\n *\n *   ```typescript\n *   // Use this:\n *   const parsed = pattern`hello \\[`;\n *   // Don't use this:\n *   const parsed = pattern`hello \\\\[`;\n *   ```\n *\n * **Examples**\n *\n * - `baz` matches `baz` exactly.\n *\n * - `b\\[ar` matches `b[ar` exactly.\n *\n * - `d?ude` matches `d`, then any character, then `ude`. All of the following\n *   strings are matched by this pattern:\n *   - `dyude`\n *   - `d;ude`\n *   - `d!ude`\n *\n * - `h[?]ello` matches either `h`, any character, then `ello` or the literal\n *   string `hello`. The set of strings it matches is equal to the union of the\n *   set of strings that the two patterns `hello` and `h?ello` match. All of the\n *   following strings are matched by this pattern:\n *   - `hello`\n *   - `h!ello`\n *   - `h;ello`\n *\n * - `|foobar|` asserts position at a word boundary, matches the literal string\n *   `foobar`, and asserts position at a word boundary:\n *   - `foobar` matches, as the start and end of string count as word\n *     boundaries;\n *   - `yofoobar` does _not_ match, as `f` is immediately preceded by a word\n *     character;\n *   - `hello foobar bye` matches, as `f` is immediately preceded by a non-word\n *     character, and `r` is immediately followed by a non-word character.\n *\n * **Grammar**\n *\n * ```\n * Pattern  ::= '['? Atom* ']'?\n * Atom     ::= Literal | Wildcard | Optional\n * Optional ::= '[' Literal | Wildcard ']'\n * Literal  ::= (NON_SPECIAL | '\\' SUPPORTS_ESCAPING)+\n *\n * NON_SPECIAL       ::= _any character other than '\\', '?', '[', ']', or '|'_\n * SUPPORTS_ESCAPING ::= '\\' | '[' | ']' | '?' | '|'\n * ```\n *\n * @example\n * ```typescript\n * const parsed = pattern`hello?`; // match \"hello\", then any character\n * ```\n * @example\n * ```typescript\n * const parsed = pattern`w[o]rld`; // match \"wrld\" or \"world\"\n * ```\n * @example\n * ```typescript\n * const parsed = pattern`my initials are \\[??\\]`; // match \"my initials are [\", then any two characters, then a \"]\"\n * ```\n * @returns The parsed pattern, which can then be used with the\n * [[RegExpMatcher]].\n * @throws [[ParserError]] if a syntactical error was detected while parsing the\n * pattern.\n * @see [[parseRawPattern]] if you want to parse a string into a pattern without\n * using a template tag.\n */\nfunction pattern(strings, ...expressions) {\n    let result = strings.raw[0];\n    for (const [i, expression] of expressions.entries()) {\n        result += expression;\n        result += strings.raw[i + 1];\n    }\n    return parser.parse(result);\n}\nexports.pattern = pattern;\n/**\n * Parses a string as a pattern directly.\n *\n * **Note**\n *\n * It is recommended to use the [[pattern | pattern template tag]] instead of\n * this function for literal patterns (i.e. ones without dynamic content).\n *\n * @param pattern - The string to parse.\n * @throws [[ParserError]] if a syntactical error was detected while parsing the\n * pattern.\n * @returns The parsed pattern, which can then be used with the\n * [[RegExpMatcher]].\n */\nfunction parseRawPattern(pattern) {\n    return parser.parse(pattern);\n}\nexports.parseRawPattern = parseRawPattern;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createStatefulTransformer = exports.createSimpleTransformer = void 0;\n/**\n * Creates a container holding the transformer function provided. Simple\n * transformers are suitable for stateless transformations, e.g., a\n * transformation that maps certain characters to others. For transformations\n * that need to keep around state, see `createStatefulTransformer`.\n *\n * @example\n * ```typescript\n * function lowercaseToUppercase(char) {\n *  return isLowercase(char) ? char - 32 : char;\n * }\n *\n * const transformer = createSimpleTransformer(lowercaseToUppercase);\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * function ignoreAllNonDigitChars(char) {\n *  return isDigit(char) ? char : undefined;\n * }\n *\n * const transformer = createSimpleTransformer(ignoreAllNonDigitChars);\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param transformer - Function that applies the transformation. It should\n * accept one argument, the input character, and return the transformed\n * character. A return value of `undefined` indicates that the character should\n * be ignored.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction createSimpleTransformer(transformer) {\n    return { type: 0 /* TransformerType.Simple */, transform: transformer };\n}\nexports.createSimpleTransformer = createSimpleTransformer;\n/**\n * Creates a container holding the stateful transformer. Stateful transformers\n * are objects which satisfy the `StatefulTransformer` interface. They are\n * suitable for transformations that require keeping around some state regarding\n * the characters previously transformed in the text.\n *\n * @example\n * ```typescript\n * class IgnoreDuplicateCharactersTransformer implements StatefulTransformer {\n *  private lastChar = -1;\n *\n *  public transform(char: number) {\n *      if (char === this.lastChar) return undefined;\n *      this.lastChar = char;\n *      return char;\n *  }\n *\n *  public reset() {\n *      this.lastChar = -1;\n *  }\n * }\n *\n * const transformer = createStatefulTransformer(() => new IgnoreDuplicateCharactersTransformer());\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param factory A function that returns an instance of the stateful\n * transformer.\n * @returns A container holding the stateful transformer, which can then be\n * passed to the [[RegExpMatcher]].\n */\nfunction createStatefulTransformer(factory) {\n    return { type: 1 /* TransformerType.Stateful */, factory };\n}\nexports.createStatefulTransformer = createStatefulTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapseDuplicatesTransformer = void 0;\nclass CollapseDuplicatesTransformer {\n    constructor({ defaultThreshold, customThresholds }) {\n        this.remaining = -1;\n        this.lastChar = -1;\n        this.defaultThreshold = defaultThreshold;\n        this.customThresholds = customThresholds;\n    }\n    transform(char) {\n        if (char === this.lastChar) {\n            return this.remaining-- > 0 ? char : undefined;\n        }\n        const threshold = this.customThresholds.get(char) ?? this.defaultThreshold;\n        this.remaining = threshold - 1;\n        this.lastChar = char;\n        return threshold > 0 ? char : undefined;\n    }\n    reset() {\n        this.remaining = -1;\n        this.lastChar = -1;\n    }\n}\nexports.CollapseDuplicatesTransformer = CollapseDuplicatesTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collapseDuplicatesTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\nconst transformer_1 = require(\"./transformer\");\n/**\n * Creates a transformer that collapses duplicate characters. This is useful for\n * detecting variants of patterns in which a character is repeated to bypass\n * detection.\n *\n * As an example, the pattern `hi` does not match `hhiii` by default, as the\n * frequency of the characters does not match. With this transformer, `hhiii`\n * would become `hi`, and would therefore match the pattern.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied after all other\n * transformers. Using it before other transformers may have the effect of not\n * catching duplicates of certain characters that were originally different but\n * became the same after a series of transformations.\n *\n * **Warning**\n *\n * This transformer should be used with caution, as while it can make certain\n * patterns match text that wouldn't have been matched before, it can also go\n * the other way. For example, the pattern `hello` clearly matches `hello`, but\n * with this transformer, by default, `hello` would become `helo` which does\n * _not_ match. In this cases, the `customThresholds` option can be used to\n * allow two `l`s in a row, making it leave `hello` unchanged.\n *\n * @example\n * ```typescript\n * // Collapse runs of the same character.\n * const transformer = collapseDuplicatesTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Collapse runs of characters other than 'a'.\n * const transformer = collapseDuplicatesTransformer({ customThresholds: new Map([['a', Infinity]]) });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param options - Options for the transformer.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction collapseDuplicatesTransformer({ defaultThreshold = 1, customThresholds = new Map(), } = {}) {\n    const map = createCharacterToThresholdMap(customThresholds);\n    return (0, Transformers_1.createStatefulTransformer)(() => new transformer_1.CollapseDuplicatesTransformer({ defaultThreshold, customThresholds: map }));\n}\nexports.collapseDuplicatesTransformer = collapseDuplicatesTransformer;\nfunction createCharacterToThresholdMap(customThresholds) {\n    const map = new Map();\n    for (const [str, threshold] of customThresholds) {\n        if (threshold < 0)\n            throw new RangeError('Expected all thresholds to be non-negative.');\n        const char = (0, Char_1.getAndAssertSingleCodePoint)(str);\n        map.set(char, threshold);\n    }\n    return map;\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.remapCharactersTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst CharacterIterator_1 = require(\"../../util/CharacterIterator\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Maps certain characters to other characters, leaving other characters\n * unchanged.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain.\n *\n * @example\n * ```typescript\n * // Transform 'a' to 'b'.\n * const transformer = remapCharactersTransformer({ 'b': 'a' });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Transform 'ðŸ…±ï¸' to 'b', and use a map instead of an object as the argument.\n * const transformer = remapCharactersTransformer(new Map([['b', 'ðŸ…±ï¸']]));\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Transform 'ðŸ‡´' and '0' to 'o'.\n * const transformer = remapCharactersTransformer({ o: 'ðŸ‡´0' });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param mapping - A map/object mapping certain characters to others.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n * @see [[resolveConfusablesTransformer|  Transformer that handles confusable Unicode characters]]\n * @see [[resolveLeetSpeakTransformer | Transformer that handles leet-speak]]\n */\nfunction remapCharactersTransformer(mapping) {\n    const map = createOneToOneMap(mapping);\n    return (0, Transformers_1.createSimpleTransformer)((c) => map.get(c) ?? c);\n}\nexports.remapCharactersTransformer = remapCharactersTransformer;\nfunction createOneToOneMap(mapping) {\n    const map = new Map();\n    const iterable = mapping instanceof Map ? mapping.entries() : Object.entries(mapping);\n    for (const [original, equivalents] of iterable) {\n        const originalChar = (0, Char_1.getAndAssertSingleCodePoint)(original);\n        const iter = new CharacterIterator_1.CharacterIterator(equivalents);\n        for (const equivalent of iter)\n            map.set(equivalent, originalChar);\n    }\n    return map;\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.confusables = void 0;\n/**\n * Maps confusable Unicode characters to their normalized equivalents.\n *\n * @copyright\n * The data here is taken from the\n * [confusables](https://github.com/gc/confusables) library.\n *\n * ```text\n * # The MIT License (MIT)\n *\n * Copyright Â© 2019 https://github.com/gc/\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the â€œSoftwareâ€), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * ```\n */\nexports.confusables = new Map([\n    [' ', ' '],\n    ['0', 'â“¿'],\n    ['1', 'â“µâžŠâ‘´Â¹ðŸðŸ™ï¼‘ðŸ·ðŸ£â’ˆðŸ­1âž€â‚â‘ â¶â¥ '],\n    ['2', 'â“¶â’‰â‘µâž‹Æ»Â²á’¿ðŸšï¼’ðŸ®ðŸ¤á’¾ðŸ¸Æ§ðŸâ‘¡á´¤â‚‚âžâ·á˜Æ¨'],\n    ['3', 'Â³â³Œêž«ðŸ‘â„¨ðŸ›ðŸ¯ðŸ¥êªâžŒÐ—Èœâ“·Ó Æ·ï¼“ðŸ¹â‘¶â’ŠÊ’Ê“Ç¯Ç®Æºð•´á¶¾Ð·á¦¡âž‚â‘¢â‚ƒá¶šá´£á´Ÿâ¸Ò˜Ò™Ó¬Ó¡Ó­ÓŸÓž'],\n    ['4', 'âžÒ¶áŽðŸœÒ·â“¸Ò¸Ò¹Ó´Óµá¶£ï¼”Ñ‡ã„©â´âžƒâ‚„â‘£â¹Ó‹â‘·â’‹'],\n    ['5', 'ðŸ±â“¹âžŽÆ¼ðŸ“ðŸ»ðŸðŸ§ï¼•âž„â‚…â‘¤âµâºÆ½â‘¸â’Œ'],\n    ['6', 'â³’á®ðŸžðŸ¨ðŸ”âžâ“ºÏ¬Ï­â¶Ð±ï¼–á§ˆâ‘¥âž…â‚†â»â‘¹â’'],\n    ['7', 'â“»ð“’âžï¼—â·â‘¦â‚‡â¼âž†â‘ºâ’Ž'],\n    ['8', 'ðŒšâž‘â“¼ï¼˜ðŸ ðŸªà§ªâ¸â‚ˆðŸ´âž‡â‘§â½ðŸ¾ðŸ–â‘»â’'],\n    ['9', 'ê®â³Šâ“½âž’à©§à§­à­¨ï¼™ðŸ«ðŸ¿ðŸ—â¹â‚‰Ô³âžˆâ‘¨â¾â‘¼â’'],\n    ['A', 'ðŸ„°áŽ¯ðŠ ð•¬ðœœð´ê“®áŽªðš¨ê­ºð–ðŸ…â„«âˆ€ðŸ‡¦â‚³ðŸ…°ð’œð˜ˆð€ð”¸Ð´Çºá—…â’¶ï¼¡Î‘á¾‹á—©Ä‚ÃƒÃ…ÇÈ€È‚Ä€ÈºÄ„ÊŒÎ›Î»Æ›á´€á´¬Ð”ÐáˆÃ„â‚á•±ÂªÇžÓ’Î†áº áº¢áº¦áº¨áº¬áº®áº°áº²áº´áº¶á¾¸á¾¹á¾ºá¾»á¾¼á¾ˆá¾‰á¾Šá¾Œá¾á¾Žá¾á¼ˆá¼‰á¼Šá¼‹á¼Œá¼á¼Žá¼á¸€È¦Ç ÓÃ€ÃÃ‚áº¤áºªð›¢ð“ð™°ð˜¼'],\n    ['a', 'âˆ‚âºâ“Õ±ÇŸáµƒá¶â’œÐ°É’ï½Î±ÈƒÈà¸„ÇŽáƒ›Ã¤É‘ÄÉÄ…á¾„áºšáº¡áº£Ç¡áº§áºµá¸È§Ó‘Ó“Ã£Ã¥Î¬á½°á½±Äƒáº©áº±áº³áº·á¾€á¾á¾‚á¾ƒá¾…á¾†á¾°á¾±á¾²á¾³á¾´á¶á¾¶á¾·á¼€á¼á¼‚á¼ƒá¼„á¼…á¼†á¼‡á¾‡áº­áº¯Ã Ã¡Ã¢áº¥áº«Ç»â±¥ðšð‘Žð’‚ð’¶ð“ªð”žð•’ð–†ð–ºð—®ð˜¢ð™–ðšŠð›‚ð›¼ðœ¶ð°ðžªâ¶'],\n    ['B', 'ðŒð‘©ð•­ðŸ„±ðŠ¡ð–¡ð˜½ê“ð—•ð˜‰ðœðŠ‚ðš©ðð›£ð—ðµð™±ð”¹á´á¼ðž‘êž´ð”…ðŸ…‘à¸¿ð“‘á—¿á—¾á—½ðŸ…±â’·ï¼¢Ð²Ïá—·Æä¹ƒÃŸáƒªáƒ©à¹–Î²É®Ð‘Õ…à¹’á™–Ê™á´®áµ‡áŒŒá¸„â„¬Î’Ð’áºžá¸‚á¸†Éƒà´¦á—¹á—¸áµá™žá™Ÿá™á›’á™—á™˜á´ƒðŸ‡§'],\n    ['b', 'áð›ð˜£ð’·ð”Ÿð“«ð–‡ð–»ð‘ð™—ð•“ð’ƒð—¯ðš‹â™­á‘³á’ˆï½‚á–šá•¹á•ºâ“‘á¸ƒá¸…ÒÑŠá¸‡ÆƒÉ“Æ…á–¯Æ„Ð¬á‘²Ã¾Æ‚â’Ðªá¶€á‘¿á’€á’‚á’á‘¾ÑŒÆ€ÒŒÑ¢Ñ£á”Ž'],\n    ['C', 'áŸâ²¤ðŸ„²ê“šðŠ¢ðŒ‚ðŸ…²ð•ðŸ…’â˜¾ÄŒÃ‡â’¸ï¼£â†ƒÆ‡á‘•ã„ˆÂ¢à¥®â†»ÄˆÏ¾Õ‡È»á™…á¶œâ’žÄ†Ò€ÄŠÂ©à¤ŸÆ†â„‚â„­Ï¹Ð¡åŒšá¸ˆÒªÊ—á‘–á‘¡á‘¢á‘£á‘¤á‘¥â…­ð‚ð¶ð‘ªð’žð“’ð•®ð–¢ð—–ð˜Šð˜¾á”'],\n    ['c', 'â²¥ð½ê®¯Ä‰ï½ƒâ“’Ä‡ÄÄ‹Ã§ÒÆˆá¸‰È¼â†„Ñáˆ­á´„Ï²Ò«ê’Ï‚É½Ï›ð™²á‘¦á§šðœð‘ð’„ð’¸ð“¬ð” ð•”ð–ˆð–¼ð—°ð˜¤ð™˜ðšŒâ‚µðŸ‡¨á¥´á’¼â…½'],\n    ['D', 'áŽ ðŸ„³ð”¡ð–‰ð”»ð——ð˜‹ð™³ð·ð““ðƒð‘«ð•¯ð–£ð”‡ð˜¿ê­°â……ð’Ÿê““ðŸ…³ðŸ…“â’¹ï¼¤Æ‰á—ªÆŠÃÔºá´…á´°â†á¸ŠÄÃžâ…®á—žá‘¯ÄŽá¸Œá¸á¸’á¸Žá—«á—¬á—Ÿá— á¶›á´†ðŸ‡©'],\n    ['d', 'á§ê“’ð“­áµ­â‚«Ôƒâ““ï½„á¸‹Äá¸á¸‘á¸“á¸Ä‘ÆŒÉ–É—áµˆâ’ŸÔâ…¾á¶Ô€á‘ºá‘»á‘¼á‘½á’„á‘°á‘±á¶‘ð••ð–½ð‘‘ð˜¥ð’…ð™™ðð—±ðšâ…†ð’¹Ê Õª'],\n    ['E', 'ê­¼ðŸ„´ð™€ð”¼ðŠ†ðš¬ê“°ðšðž”ð“”ð‘¬ð—˜ðŸ…´ðŸ…”â’ºÎˆï¼¥ÆŽá¼á•®Æãƒ¢Ð„á´‡á´±áµ‰Ã‰ä¹‡ÐÉ†ê‚…â‚¬Ãˆâ„°Î•Ð•â´¹áŽ¬Ä’Ä”Ä–Ä˜ÄšÃŠÃ‹Ôá»€áº¾á»„á»‚áº¼á¸”á¸–áººÈ„È†áº¸á»†È¨á¸œá¸˜á¸šá¼˜á¼™á¼šá¼›á¼œá¿ˆá¿‰Ó–á½²á½³Ð€ÏµðŸ‡ª'],\n    ['e', 'ð‘’ð“®ð•–ð–Šð˜¦ð—²ðšŽð™šð’†ð”¢ð–¾ðžÒ¾Ò¿â“”ï½…â’ Ã¨á§‰Ã©á¶’ÃªÉ˜á¼”á»áº¿á»…à«¯ÇÑ”ÎµÄ“Ò½É›á»ƒáº½á¸•á¸—Ä•Ä—Ã«áº»Ä›È…È‡áº¹á»‡È©É‡â‚‘Ä™á¸á¸™á¸›â„®ÐµÔ‘ÑÓ—á¥±Ñ‘á¼á¼‘á¼’á¼“á¼•â„¯'],\n    ['F', 'ðŸ„µðŠ‡ð”‰ð˜ðŠ¥ê“êž˜ðŸ…µðŸ…•ð“•â’»ï¼¦Ò“Ò’á–´Æ‘Ô²Ïá‰»á¸žâ„±Ïœâ‚£ðŸ‡«â„²'],\n    ['f', 'ðŸð–‹â“•ï½†Æ’á¸ŸÊƒÕ¢á¶ â’¡Å¿êŠ°Ê„âˆ±á¶‚ð˜§'],\n    ['G', 'ê“–á³ðŸ„¶á€á»ð”¾ð“–ð‘®ð•²ê®ð’¢ð™‚ð–¦ð™¶ð”Šðºð†ðŸ…¶ðŸ…–â’¼ï¼§É¢Æ“Ê›Ä¢á˜œá´³Ç´Ä ÔŒÄœá¸ ÄžÇ¦Ç¤Ôâ‚²ðŸ‡¬â…'],\n    ['g', 'â“–ï½‡ÇµÄá¸¡ÄŸÄ¡Ç§Ä£Öà«­Ç¥É ï»­ï»®áµâ’¢â„ŠÉ¡á§ð ð‘”ð’ˆð“°ð”¤ð•˜ð–Œð—€ð—´ð˜¨ð™œðš'],\n    ['H', 'ðŸ„·ðœ¢ê“§ð˜ð»ðœð–§ð‹ð—›ê®‹â„áŽ»â„Œâ²Žð‘¯ðž–ðŸ…·ðŸ…—á‹žÇ¶Ô‹â’½ï¼¨Ä¤ášºá¸¢á¸¦Èžá¸¤á¸¨á¸ªÄ¦â±§Ò¢Ò£Ò¤á¿Šá¿‹á¿Œá¼¨á¼©á¼ªá¼«á¼­á¼®á¼¯á¾˜á¾™á¾šá¾›á¾œá¾á¾žá¾ŸÓ‰ÓˆÒ¥Î‰Ð½å„â™“ð“—â„‹Ðð‡ð™ƒð™·Êœð›¨Î—ðš®á•¼Ó‡á´´áµ¸ðŸ‡­'],\n    ['h', 'Òºâ’£Ñ’â“—ï½ˆÄ¥á¸£á¸§ÈŸá¸¥á¸©á¸«áº–Ä§â±¨Õ°Ò»áŠ¨áŠ©áŠªáŠ«É¦â„Žð¡ð’‰ð’½ð“±ð”¥ð•™ð–ð—ð—µð˜©ð™ðš‘Õ«Ê°á‘‹á—É§ã‚“É¥'],\n    ['I', 'ðŸ„¸Ð‡ê€¤á†ðŸ…¸ðŸ…˜Ø¥ïº‡Ù³Ø£ïºƒÙ²Ùµâ’¾ï¼©áŸ¸ÃŒÃÃŽÄ¨ÄªÄ¬Ä°Ãá¸®á»ˆÇÈˆÈŠá»ŠÄ®á¸¬Æ—ã‚§ã‚¨á¿˜á¿™á¿šá¿›á¼¸á¼¹á¼ºá¼»á¼¼á¼½á¼¾â… ÎªÎŠÉªá¶¦á‘Šá¥£ð›ªðˆð™„ð™¸ð“µð™¡ð¼á´µðš°ð‘°ðŸ‡®'],\n    ['i', 'â“˜ï½‰Ã¬Ã­Ã®Ä©Ä«Ä­Ã¯á¸¯á»‰ÇÈ‰È‹á»‹á¸­á¿á¿‘á¿’á¿“á¿–á¿—á¼°á¼±á¼²â…°â…¼âˆ£âµï¿¨×€Ø§Ù¡Û±ßŠá›á¼³á¼´á¼µÉ¨Ñ–á½¶á½·á¶–ð”¦ðš’ð¸ð—‚ð¢ð•šð–Žð—¶ð˜ªð™žÎ¯â±áµ¢ð“²â’¤'],\n    ['J', 'ðŸ„¹ðŸ…¹ðŸ…™â’¿ï¼ªÐˆÊá’× ï¾ŒÄ´Ê†à¸§Ù„ÕµÊ–á´Šá´¶ï»áŒ‹Éˆâ±¼Õ‚à¹…á‚±Ä¯áŽ«È·ä¸¿â„â„‘á’˜á’™á’šá’›á’´á’µá’Žá’ðŸ‡¯'],\n    ['j', 'â“™ï½ŠÏ³Ê²â’¥É‰ÄµÇ°Ñ˜Ú¶á¶¨ð’¿ð˜«ð—·ð‘—ð™Ÿð”§ð’‹ð—ƒð“³ð•›ðš“ð–ð£'],\n    ['K', 'ð—žðŸ„ºðœ¥ð˜’ê“—ð™†ð•‚â²”ð”Žð›«á¦ðž™ð’¦ðŸ…ºðŸ…šâ‚­â“€ï¼«Ä¸á¸°ÑœÆ˜ÐºÒ ÎºÒ›ÒŸÓ„ÊžÒšÐšÒ¡á´‹á´·áµâ’¦á›•ÐŒáŒ•á¸²Îšâ„ªÒœÒÒžÄ¶á¸´Ç¨â±©Ï—ÓƒðŸ‡°'],\n    ['k', 'â“šï½‹á¸±Ç©á¸³Ä·á¸µÆ™â±ªá¶„ð¤ð˜¬ð—„ð•œðœ…ðœ˜ðœ¿ð’ð¹ðžŒðž³ð™ ðš”ð‘˜ð’ŒÏ°ð›‹ð›žðŸ†ð—¸ð“´ð“€'],\n    ['L', 'ðŸ„»ð›â³ð‘³ð™»ð‘ƒð“›â³‘ê®®ážê“¡ðŸ…»ðŸ…›ïºˆâ””â“Ö‚ï¼¬Ä¿á’ªä¹šÕ†ÊŸê“¶Î¹Ô¼á´¸Ë¡Ä¹áˆ¨á¸¶â‚—Î“Õ¬Ä»á„‚â…¬â„’â±¢á¥§á¥¨á’»á’¶á’·á¶«ïºŽá’ºá’¹á’¸á’«âŽ³ã„¥Åâ± ïº„È½ðŸ‡±'],\n    ['l', 'â“›ï½ŒÅ€ÄºÄ¾á¸·á¸¹Ä¼Ó€â„“á¸½á¸»Å‚ï¾šÉ­ÆšÉ«â±¡|Æ–â’§Ê…Ç€×•×ŸÎ™Ð†ï½œá¶©Óð“˜ð•€ð–¨ð—œð˜ð¥ð‘™ð’ð“ð”©ð•ð–‘ð—…ð—¹ð˜­ðš•ðœ¤ðžÄ±ðš¤É©á¾¾ð›Šðœ„ðœ¾ðž²'],\n    ['M', 'ðŸ„¼ðŒ‘ðŠ°ê“Ÿâ²˜áŽ·ðŸ…¼ðŸ…œâ“‚ï¼­Ð¼á¹‚àµ±á—°å·žá˜»áƒà¹“â™Êá™á´á´¹áµâ’¨á¸¾Ðœá¹€à¯±â…¯â„³ÎœÏºá›–ÓÓŽðŒð‘€ð‘´ð“œð”ð•„ð•¸ð–¬ð— ð˜”ð™ˆð™¼ðš³ð›­ðœ§ð¡ðž›ðŸ‡²'],\n    ['m', 'â‚¥áµ¯ð–’ð¦ð—†ð”ªð•žð“‚â“œï½à´¨á™¢àµ©á¸¿á¹â…¿Ï»á¹ƒáŒ É±áŸ³á¶†ð™¢ð“¶ðš–ð‘šð—ºá§•á§—'],\n    ['N', 'ðŸ„½â„•ê“ ð›®ð¢ð™½ðš´ð‘µð‘â²šðð’©ðžœð—¡ð˜•ðœ¨ð“ð–­ðŸ…½â‚¦ðŸ…Ð™Ðâ“ƒÒ‹áŸ·ï¼®á´ŽÉ´Æá‘Žå‡ Ð¸ÕˆÕ¼Ð˜×”Ð›Ï€á´ºá¶°Åƒåˆ€áŠ­á¹„â¿Ã‘ÐŸÎá´¨Õ¸Ï–Ç¸Å‡á¹†Å…á¹Šá¹ˆà¸—ÅŠÓ¢Ó£Ó¤Ó¥Ñ›ÑÐ¹á¥¢ÒŠá´»ðŸ‡³'],\n    ['n', '×—ð’ð“·ð™£ð‘›ð–“ð”«ð—‡ðš—ð—»á¥’â“Î®ï½ŽÇ¹á´’Å„Ã±á¾—Î·á¹…Åˆá¹‡É²Å†á¹‹á¹‰Õ²àº–ÕŒÆžÅ‹â’©à¸ à¸É³Ð¿Å‰Ð»Ô‰È á¼ á¼¡á¿ƒÕ¤á¾á¾‘á¾’á¾“á¾”á¾•á¾–á¿„á¿†á¿‡á¿‚á¼¢á¼£á¼¤á¼¥á¼¦á¼§á½´á½µá‰ á‰¡á‰¢á‰£á‰¤á‰¥á‰¦Èµð›ˆðœ‚ðœ¼ð¶ðž°ð•Ÿð˜¯ð§ð“ƒá¶‡áµ°á¥¥âˆ©'],\n    [\n        'O',\n        'ê„²ðŸ„¾ðŠ’ðŸ¬ê“³â²žð„ðŠ«ð“‚ðžžðŸ…žâ¥â—¯âµâŠ–ï¼âŠð¤Ñ²Ï´ðš¶ðœªÑºÓ¦Ó¨ÓªÎŒÊ˜ðŽÇ‘Ã’ÅŽÃ“Ã”Ã•ÈŒÈŽã‡¿ââ“„ï¼¯á½‹ãƒ­â¤à«¦âŠ•Ã˜Ð¤Ô¾Î˜Æ á´¼áµ’â’ªÅÃ–â‚’Â¤â—ŠÎ¦ã€‡ÎŸÐžÕ•à¬ à´ à¯¦×¡á»’á»á»–á»”á¹ŒÈ¬á¹ŽÅŒá¹á¹’È®È°Èªá»Žá»œá»šá» á»žá»¢á»Œá»˜ÇªÇ¬Ç¾ÆŸâµ”ß€áŸ°âœâŽ”âŽ•â¦°â¦±â¦²â¦³â¦´â¦µâ¦¶â¦·â¦¸â¦¹â¦ºâ¦»â¦¼â¦½â¦¾â¦¿â§€â§â§‚â§ƒá½ˆá½‰á½Šá½Œá½',\n    ],\n    [\n        'o',\n        'ðš˜ð›ð—ˆðž¼á€â²Ÿð™¤á€ð¬ð”¬ð“ªð“¸ðŸ‡´â¤â—‹Ï™ðŸ…¾ð’ªð–®ðŸ¢ðŸ¶ð™¾ð˜°ð—¼ð• ðœŠð¨ð¾ðž¸á¤â“žÑ³á§á¥²Ã°ï½à° á¦žÕ“Ã²Ó©Ó§Ã³ÂºÅÃ´Ç’ÈÅá»“á»‘Èá»—á»•ÃµÏƒá¹È­á¹á½„á¹‘á¹“È¯È«à¹á´Å‘Ã¶Ñ»Ð¾á‹Ç­È±à§¦à­¦Ù¥à±¦à³¦àµ¦à¹à»Î¿Ö…á´‘à¥¦à©¦á»Æ¡á»á»›á»¡á»Ÿá»£á»á»™Ç«Ã¸Ç¿ÉµÕ®á½€á½ÏŒá½¸á½¹á½‚á½ƒá½…',\n    ],\n    ['P', 'ðŸ„¿ê“‘ðš¸ð™¿ðž ð™‹ê®²â²¢ð’«ð¦ð‘ƒð‘·ð—£ððŠ•ðœ¬ð˜—ð“Ÿð–¯ð›²á¢ðŸ…ŸÒŽðŸ…¿â“…ï¼°Æ¤á‘­å°¸á¹–Ö€Ï†Ö„á´˜á´¾áµ–â’«á¹”ï½±×§Ð á‹¨á´©â±£â„™Î¡á¿¬á‘¸á‘¶á‘·á‘¹á‘¬á‘®ðŸ‡µâ‚±'],\n    ['p', 'Òâ„—â“Ÿï½á¹•á¹—Æ¥áµ½á¿¥ÏÑ€Æ¿Ç·á¿¤â´ð“¹ð“…ð©ð‘ð’‘ð”­ð•¡ð–•ð—‰ð—½ð˜±ð™¥ðš™ð›’ð†ðžºðœŒðž€'],\n    ['Q', 'ðŸ…€ðŸ†€ðŸ… â“†ï¼±â„šâµ•Ôšðð‘„ð‘¸ð’¬ð“ ðš€ð˜˜ð™Œð–°ð•¼ð””ð—¤ðŸ‡¶'],\n    ['q', 'â“ ï½‘Õ£â’¬Û¹Õ¦á‘«É‹ÉŠÔ›ð—Šð‘žð˜²ð•¢ðššð’’ð––ðªð”®ð“ºð™¦'],\n    ['R', 'â„žâ„Ÿê­±á’ð’´ê®¢áŽ¡ê“£ðŸ†ðŸ…¡â“‡ï¼²á´™È’Ê€á–‡Ñå°ºÅ”Ð¯àª°Æ¦á´¿á‹ªá¹šÉŒÊâ„›â„œâ„á¹˜Å˜Èá¹œÅ–á¹žâ±¤ð‘ð‘…ð‘¹ð“¡ð•½ð–±ð—¥ð˜™ð™ðšáš±ðŸ‡·á´š'],\n    ['r', 'â“¡ï½’Å•á¹™Å™È‘È“á¹›á¹Å—Ð³ÕÉ¾á¥¬á¹ŸÉÊ³â’­É¼Ñ“á´¦á¶‰ð«ð‘Ÿð’“ð“‡ð“»ð”¯ð•£ð–—ð—‹ð—¿ð˜³ð™§áµ²Ò‘áµ£'],\n    ['S', 'ðŸ…‚ê‡™ð“¢ð—¦ášð’®á•ðš‚ð’ê“¢ð–²ð”–ð™ŽðŠ–ð•¾ð ð˜šð•Šð‘†ð‘ºðŸ†‚ðŸ…¢â“ˆï¼³á¹¨ÅžÖ†ÕÈ˜Ë¢â’®Ð…á¹ Å Åšá¹¤Åœá¹¦á¹¢à´Ÿá”•á”–á”¢á”¡á”£á”¤'],\n    ['s', 'â“¢êœ±ð‘ˆê®ªï½“Å›á¹¥Åá¹¡Å¡á¹§Ê‚á¹£á¹©Ñ•ÅŸÈ™È¿á¶Šà°•ð¬ð‘ ð’”ð“ˆð“¼ð”°ð•¤ð–˜ð—Œð˜€ð˜´ð™¨ðšœÞŽðŸ‡¸'],\n    ['T', 'ðŸ…ƒðŸ†ƒðŒ•ðš»ð›µð•‹ð•¿ð‘»ðŠ±ðŠ—ð–³ð™ðŸ¨ð©ðž£ðšƒð˜›ð‘‡ê“”âŸ™ð“â²¦ð—§âŠ¤ð”—áŽ¢ê­²ð’¯ðŸ…£â‡â‰â“‰ï¼´Ñ‚Ò¬Ò­Æ¬ã‚¤Å¦ÔµÏ„á´›áµ€ï½²á•Ï®Å¤âŠ¥Æ®Î¤Ð¢ä¸‹á¹ªá¹¬ÈšÅ¢á¹°á¹®ä¸…ä¸áªð›•ðœð‰ðžƒðž½ð“£ã„’ðŸ‡¹áŒ¥'],\n    ['t', 'â“£ï½”á¹«áº—Å¥á¹­È›È¶à©®Õ§Ê‡â€ Å£á¹±á¹¯Æ­Å§áµ—â’¯ÊˆÕ¥Æ«ð­ð‘¡ð’•ð“‰ð“½ð”±ð•¥ð–™ð—ð˜ð˜µð™©ðšãƒŠ'],\n    ['U', 'ðŸ…„ê“´ð“Žê’¤ðŸ†„ðŸ…¤Å¨Å¬Å®á‘—á‘˜Ç“Ç•Ç—Ç™â“Šï¼µÈ–á‘Œå‡µÆ±Õ´Ô±ê“µÐ¦ÅªÕ„Æ²á™€áµáµ˜â’°Å°àªªÃœÕÃ™ÃšÃ›á¹¸á¹ºÇ›á»¦È”Æ¯á»ªá»¨á»®á»¬á»°á»¤á¹²Å²á¹¶á¹´É„á¥©á‘§âˆªá˜®â‹ƒð”ð‘ˆð‘¼ð’°ð“¤ð”˜ð•Œð–€ð–´ð—¨ð˜œð™ðš„ðŸ‡º'],\n    ['u', 'á½ºá½»â“¤ï½•Ã¹Å©Å«á»«á¹·á¹¹Å­Ç–á»¯á¥™ÇšÇœá½—Ï…Î°à¸™Õ½ÊŠÇ˜Ç”ÃºÅ¯á´œÅ±Å³à¸¢Ã»á¹»Ñ†áˆÃ¼áµ¾áµ¤ÂµÊ‹á»§È•È—Æ°á»©á»­á»±á»¥á¹³á¹µÊ‰á¿ á¿¡á¿¢á¿£á¿¦á¿§á½á½‘Ï‹Ïá½’á½“á½”á½•á½–á¥”ð®ð‘¢ð’–ð“Šð“¾ð”²ð•¦ð–šð—Žá¶™'],\n    ['V', 'ðŸ……ê“¦ð‘½ð–µð˜á™ðš…ð™‘ð•ðŸ†…ðŸ…¥â“‹ï¼¶á¯Ñ´áµ›â’±Û·á¹¾â…´â…¤á¹¼Ù§â´¸Ñ¶áºá»ðŸ‡»ð“¥'],\n    ['v', 'áˆ€â“¥ï½–ðœðŠá¹½á¹¿à±®à¸‡Ñµ×¢á´ Î½×˜áµ¥Ñ·áŸ´á˜ð™«ðšŸð›Žðœˆð‚ð¼ðž¶ð˜·ð˜ƒð“¿'],\n    ['W', 'ðŸ…†á”áŽ³ð‘¾ê“ªð’²ð˜žðŸ††â“ŒðŸ…¦ï½—ï¼·áº‚á¾§á—¯á¥•å±±Ñ àºŸà°šÕ¡Ð©Ð¨ÏŽÑ‰à¸¬Ñˆá™Žáµ‚Ê·â’²à¸áˆ áº„Ôœáº€Å´áº†áºˆà´§á˜ºÑ¿á™¡Æœâ‚©ðŸ‡¼'],\n    ['w', 'áºê®ƒáºƒâ“¦âµÅµáº‡áº…áº˜áº‰â±³á½¼á½ á½¡á½¢á½£Ï‰á½¤á½¥á½¦á½§á¿²á¿³á¿´á¿¶á¿·â±²Ñ¡Ôá´¡á½½á¾ á¾¡á¾¢á¾£á¾¤á¾¥á¾¦É¯ð•ðŸ‰ðž'],\n    ['X', 'ðŸž¨ðŸž©ðŸžªðŸ…‡ðŸž«ðŸž¬ðŒ—â²¬ê“«ð–ƒðž¦ð˜ŸðŠðš¾ð¬ðœ²êž³ðŒ¢ð–·ð‘‹ð•ð”›ðŠ´ð—«ðŸ†‡ðŸ…§âŒâ“ð“§ï¼¸áºŠá™­Ï‡ã„¨ð’³Ó¾áƒ¯Ó¼Ò³Ð–Î§Ò²áµ¡Ë£â’³×áˆ¸áºŒêŠ¼â…©Ð¥â•³á™®á•á•½â…¹áš·âµð™“ðš‡ä¹‚ð—ðŸ‡½'],\n    ['x', 'â“§ï½˜Ñ…áº‹Ã—â‚“â¤«â¤¬â¨¯áºá¶ð™­Ó½ð˜¹ð±ðš¡â¨°ï¾’ð”'],\n    ['Y', 'â²¨ðšˆð‘Œð—¬ð˜ê“¬ð’€ðœ°ðŠ²ðŸ†ˆðŸ…¨â“Žï¼¹á½›Æ³ã„šÊâ…„Ï”ï¿¥Â¥ÕŽÏ“Î³×¥Ó²Ð§ÐŽáˆƒÅ¸ÉŽÏ¤Î¥Ï’Ò®á»²ÃÅ¶á»¸È²áºŽá»¶á»´á¿¨á¿©á¿ªá¿«á½™á½á½ŸÎ«ÎŽÓ®Ó°Ò°Ò±ð•ðŸ‡¾'],\n    ['y', 'ðŸ…ˆáŽ½áŽ©â“¨ï½™á»³Ã½Å·á»¹È³áºÃ¿á»·Ñƒáƒ§áº™á»µÆ´ÉáµžÉ£Ê¸á¶ŒÒ¯â’´Ó³Ó±Ó¯ÑžÐ£ÊŽ'],\n    ['Z', 'ðŸ…‰ê“œð—­ð™â˜¡áƒð˜¡ðŸ†‰ðŸ…©â“ï¼ºáº”Æµä¹™áºÈ¤á¶»â’µÅ¹â„¤Î–Å»Å½áº’â±«ðŸ‡¿'],\n    ['z', 'ê®“â“©ï½šÅºáº‘Å¼Å¾áº“áº•Æ¶È¥É€á´¢áŒŠÊâ±¬á¶ŽÊ‘á™†'],\n]);\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveConfusablesTransformer = void 0;\nconst remap_characters_1 = require(\"../remap-characters\");\nconst confusables_1 = require(\"./confusables\");\n/**\n * Creates a transformer that maps confusable Unicode characters to their\n * normalized equivalent. For example, `â“µ`, `âžŠ`, and `â‘´` become `1` when using\n * this transformer.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain.\n *\n * @example\n * ```typescript\n * const transformer = resolveConfusablesTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction resolveConfusablesTransformer() {\n    return (0, remap_characters_1.remapCharactersTransformer)(confusables_1.confusables);\n}\nexports.resolveConfusablesTransformer = resolveConfusablesTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dictionary = void 0;\nexports.dictionary = new Map([\n    ['a', '@4'],\n    ['c', '('],\n    ['e', '3'],\n    ['i', '1|!'],\n    ['g', '6'],\n    ['o', '0'],\n    ['s', '$5'],\n    ['t', '7'],\n    ['z', '2'],\n]);\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveLeetSpeakTransformer = void 0;\nconst remap_characters_1 = require(\"../remap-characters\");\nconst dictionary_1 = require(\"./dictionary\");\n/**\n * Creates a transformer that maps leet-speak characters to their normalized\n * equivalent. For example, `$` becomes `s` when using this transformer.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain, but after similar transformers that map characters to\n * other characters, such as the [[resolveConfusablesTransformer | transformer\n * that resolves confusable Unicode characters]].\n *\n * @example\n * ```typescript\n * const transformer = resolveLeetSpeakTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction resolveLeetSpeakTransformer() {\n    return (0, remap_characters_1.remapCharactersTransformer)(dictionary_1.dictionary);\n}\nexports.resolveLeetSpeakTransformer = resolveLeetSpeakTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toAsciiLowerCaseTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Creates a transformer that changes all ASCII alphabet characters to\n * lower-case, leaving other characters unchanged.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the end of the\n * transformer chain. Using it before other transformers may have the effect of\n * making its changes useless as transformers applied after produce characters\n * of varying cases.\n *\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction toAsciiLowerCaseTransformer() {\n    return (0, Transformers_1.createSimpleTransformer)((c) => ((0, Char_1.isUpperCase)(c) ? (0, Char_1.invertCaseOfAlphabeticChar)(c) : c));\n}\nexports.toAsciiLowerCaseTransformer = toAsciiLowerCaseTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.englishDataset = exports.englishRecommendedTransformers = exports.englishRecommendedWhitelistMatcherTransformers = exports.englishRecommendedBlacklistMatcherTransformers = void 0;\nconst DataSet_1 = require(\"../dataset/DataSet\");\nconst Pattern_1 = require(\"../pattern/Pattern\");\nconst collapse_duplicates_1 = require(\"../transformer/collapse-duplicates\");\nconst resolve_confusables_1 = require(\"../transformer/resolve-confusables\");\nconst resolve_leetspeak_1 = require(\"../transformer/resolve-leetspeak\");\nconst to_ascii_lowercase_1 = require(\"../transformer/to-ascii-lowercase\");\n/**\n * A set of transformers to be used when matching blacklisted patterns with the\n * [[englishDataset | english word dataset]].\n */\nexports.englishRecommendedBlacklistMatcherTransformers = [\n    (0, resolve_confusables_1.resolveConfusablesTransformer)(),\n    (0, resolve_leetspeak_1.resolveLeetSpeakTransformer)(),\n    (0, to_ascii_lowercase_1.toAsciiLowerCaseTransformer)(),\n    // See #23 and #46.\n    // skipNonAlphabeticTransformer(),\n    (0, collapse_duplicates_1.collapseDuplicatesTransformer)({\n        defaultThreshold: 1,\n        customThresholds: new Map([\n            ['b', 2],\n            ['e', 2],\n            ['o', 2],\n            ['l', 2],\n            ['s', 2],\n            ['g', 2], // ni_gg_er\n        ]),\n    }),\n];\n/**\n * A set of transformers to be used when matching whitelisted terms with the\n * [[englishDataset | english word dataset]].\n */\nexports.englishRecommendedWhitelistMatcherTransformers = [\n    (0, to_ascii_lowercase_1.toAsciiLowerCaseTransformer)(),\n    (0, collapse_duplicates_1.collapseDuplicatesTransformer)({\n        defaultThreshold: Number.POSITIVE_INFINITY,\n        customThresholds: new Map([[' ', 1]]), // collapse spaces\n    }),\n];\n/**\n * Recommended transformers to be used with the [[englishDataset | english word\n * dataset]] and the [[RegExpMatcher]].\n */\nexports.englishRecommendedTransformers = {\n    blacklistMatcherTransformers: exports.englishRecommendedBlacklistMatcherTransformers,\n    whitelistMatcherTransformers: exports.englishRecommendedWhitelistMatcherTransformers,\n};\n/**\n * A dataset of profane English words.\n *\n * @example\n * ```typescript\n * const matcher = new RegExpMatcher({\n * \t...englishDataset.build(),\n * \t...englishRecommendedTransformers,\n * });\n * ```\n * @example\n * ```typescript\n * // Extending the data-set by adding a new word and removing an existing one.\n * const myDataset = new DataSet()\n * \t.addAll(englishDataset)\n * \t.removePhrasesIf((phrase) => phrase.metadata.originalWord === 'vagina')\n * \t.addPhrase((phrase) => phrase.addPattern(pattern`|balls|`));\n * ```\n * @copyright\n * The words are taken from the [cuss](https://github.com/words/cuss) project,\n * with some modifications.\n *\n * ```text\n * (The MIT License)\n *\n * Copyright (c) 2016 Titus Wormer <tituswormer@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * ```\n */\nexports.englishDataset = new DataSet_1.DataSet()\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'abo' }).addPattern((0, Pattern_1.pattern) `|ab[b]o[s]|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'abeed' }).addPattern((0, Pattern_1.pattern) `ab[b]eed`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'africoon' }).addPattern((0, Pattern_1.pattern) `africoon`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'anal' })\n    .addPattern((0, Pattern_1.pattern) `|anal`)\n    .addWhitelistedTerm('analabos')\n    .addWhitelistedTerm('analagous')\n    .addWhitelistedTerm('analav')\n    .addWhitelistedTerm('analy')\n    .addWhitelistedTerm('analog')\n    .addWhitelistedTerm('an al')\n    .addPattern((0, Pattern_1.pattern) `danal`)\n    .addPattern((0, Pattern_1.pattern) `eanal`)\n    .addPattern((0, Pattern_1.pattern) `fanal`)\n    .addWhitelistedTerm('fan al')\n    .addPattern((0, Pattern_1.pattern) `ganal`)\n    .addWhitelistedTerm('gan al')\n    .addPattern((0, Pattern_1.pattern) `ianal`)\n    .addWhitelistedTerm('ian al')\n    .addPattern((0, Pattern_1.pattern) `janal`)\n    .addWhitelistedTerm('trojan al')\n    .addPattern((0, Pattern_1.pattern) `kanal`)\n    .addPattern((0, Pattern_1.pattern) `lanal`)\n    .addWhitelistedTerm('lan al')\n    .addPattern((0, Pattern_1.pattern) `lanal`)\n    .addWhitelistedTerm('lan al')\n    .addPattern((0, Pattern_1.pattern) `oanal|`)\n    .addPattern((0, Pattern_1.pattern) `panal`)\n    .addWhitelistedTerm('pan al')\n    .addPattern((0, Pattern_1.pattern) `qanal`)\n    .addPattern((0, Pattern_1.pattern) `ranal`)\n    .addPattern((0, Pattern_1.pattern) `sanal`)\n    .addPattern((0, Pattern_1.pattern) `tanal`)\n    .addWhitelistedTerm('tan al')\n    .addPattern((0, Pattern_1.pattern) `uanal`)\n    .addWhitelistedTerm('uan al')\n    .addPattern((0, Pattern_1.pattern) `vanal`)\n    .addWhitelistedTerm('van al')\n    .addPattern((0, Pattern_1.pattern) `wanal`)\n    .addPattern((0, Pattern_1.pattern) `xanal`)\n    .addWhitelistedTerm('texan al')\n    .addPattern((0, Pattern_1.pattern) `yanal`)\n    .addPattern((0, Pattern_1.pattern) `zanal`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'anus' })\n    .addPattern((0, Pattern_1.pattern) `anus`)\n    .addWhitelistedTerm('an us')\n    .addWhitelistedTerm('tetanus')\n    .addWhitelistedTerm('uranus')\n    .addWhitelistedTerm('janus')\n    .addWhitelistedTerm('manus'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'arabush' }).addPattern((0, Pattern_1.pattern) `arab[b]ush`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'arse' })\n    .addPattern((0, Pattern_1.pattern) `|ars[s]e`)\n    .addWhitelistedTerm('arsen'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'ass' })\n    .addPattern((0, Pattern_1.pattern) `|ass`)\n    .addWhitelistedTerm('assa')\n    .addWhitelistedTerm('assem')\n    .addWhitelistedTerm('assen')\n    .addWhitelistedTerm('asser')\n    .addWhitelistedTerm('asset')\n    .addWhitelistedTerm('assev')\n    .addWhitelistedTerm('assi')\n    .addWhitelistedTerm('assoc')\n    .addWhitelistedTerm('assoi')\n    .addWhitelistedTerm('assu'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bastard' }).addPattern((0, Pattern_1.pattern) `bas[s]tard`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bestiality' }).addPattern((0, Pattern_1.pattern) `be[e][a]s[s]tial`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'bitch' })\n    .addPattern((0, Pattern_1.pattern) `bitch`)\n    .addPattern((0, Pattern_1.pattern) `bich|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'blowjob' }).addPattern((0, Pattern_1.pattern) `b[b]l[l][o]wj[o]b`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bollocks' }).addPattern((0, Pattern_1.pattern) `bol[l]ock`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'boob' }).addPattern((0, Pattern_1.pattern) `boob`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'boonga' })\n    .addPattern((0, Pattern_1.pattern) `boonga`)\n    .addWhitelistedTerm('baboon ga'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'buttplug' }).addPattern((0, Pattern_1.pattern) `buttplug`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'chingchong' }).addPattern((0, Pattern_1.pattern) `chingchong`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'chink' })\n    .addPattern((0, Pattern_1.pattern) `chink`)\n    .addWhitelistedTerm('chin k'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cock' })\n    .addPattern((0, Pattern_1.pattern) `|cock|`)\n    .addPattern((0, Pattern_1.pattern) `|cocks`)\n    .addPattern((0, Pattern_1.pattern) `|cockp`)\n    .addPattern((0, Pattern_1.pattern) `|cocke[e]|`)\n    .addWhitelistedTerm('cockney'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cuck' })\n    .addPattern((0, Pattern_1.pattern) `cuck`)\n    .addWhitelistedTerm('cuckoo'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cum' })\n    .addPattern((0, Pattern_1.pattern) `|cum`)\n    .addWhitelistedTerm('cumu')\n    .addWhitelistedTerm('cumb'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cunt' })\n    .addPattern((0, Pattern_1.pattern) `|cunt`)\n    .addPattern((0, Pattern_1.pattern) `cunt|`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'deepthroat' })\n    .addPattern((0, Pattern_1.pattern) `deepthro[o]at`)\n    .addPattern((0, Pattern_1.pattern) `deepthro[o]t`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'dick' })\n    .addPattern((0, Pattern_1.pattern) `|dck|`)\n    .addPattern((0, Pattern_1.pattern) `dick`)\n    .addWhitelistedTerm('benedick')\n    .addWhitelistedTerm('dickens'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'dildo' }).addPattern((0, Pattern_1.pattern) `dildo`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'doggystyle' }).addPattern((0, Pattern_1.pattern) `d[o]g[g]ys[s]t[y]l[l]`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'double penetration' }).addPattern((0, Pattern_1.pattern) `double penetra`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'dyke' })\n    .addPattern((0, Pattern_1.pattern) `dyke`)\n    .addWhitelistedTerm('van dyke'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'ejaculate' })\n    .addPattern((0, Pattern_1.pattern) `e[e]jacul`)\n    .addPattern((0, Pattern_1.pattern) `e[e]jakul`)\n    .addPattern((0, Pattern_1.pattern) `e[e]acul[l]ate`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'fag' })\n    .addPattern((0, Pattern_1.pattern) `|fag`)\n    .addPattern((0, Pattern_1.pattern) `fggot`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'felch' }).addPattern((0, Pattern_1.pattern) `fe[e]l[l]ch`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fellatio' }).addPattern((0, Pattern_1.pattern) `f[e][e]llat`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'finger bang' }).addPattern((0, Pattern_1.pattern) `fingerbang`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fisting' }).addPattern((0, Pattern_1.pattern) `fistin`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'fuck' })\n    .addPattern((0, Pattern_1.pattern) `f[?]ck`)\n    .addPattern((0, Pattern_1.pattern) `|fk`)\n    .addPattern((0, Pattern_1.pattern) `|fu|`)\n    .addPattern((0, Pattern_1.pattern) `|fuk`)\n    .addWhitelistedTerm('fick')\n    .addWhitelistedTerm('kung-fu')\n    .addWhitelistedTerm('kung fu'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'gangbang' }).addPattern((0, Pattern_1.pattern) `g[?]ngbang`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'handjob' }).addPattern((0, Pattern_1.pattern) `h[?]ndjob`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'hentai' }).addPattern((0, Pattern_1.pattern) `h[e][e]ntai`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'hooker' }).addPattern((0, Pattern_1.pattern) `hooker`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'incest' }).addPattern((0, Pattern_1.pattern) `incest`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'jerk off' }).addPattern((0, Pattern_1.pattern) `jerkoff`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'jizz' }).addPattern((0, Pattern_1.pattern) `jizz`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'kike' }).addPattern((0, Pattern_1.pattern) `kike`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'lubejob' }).addPattern((0, Pattern_1.pattern) `lubejob`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'masturbate' })\n    .addPattern((0, Pattern_1.pattern) `m[?]sturbate`)\n    .addPattern((0, Pattern_1.pattern) `masterbate`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'negro' })\n    .addPattern((0, Pattern_1.pattern) `negro`)\n    .addWhitelistedTerm('montenegro')\n    .addWhitelistedTerm('negron')\n    .addWhitelistedTerm('stoneground')\n    .addWhitelistedTerm('winegrow'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'nigger' })\n    .addPattern((0, Pattern_1.pattern) `n[i]gger`)\n    .addPattern((0, Pattern_1.pattern) `n[i]gga`)\n    .addPattern((0, Pattern_1.pattern) `|nig|`)\n    .addPattern((0, Pattern_1.pattern) `|nigs|`)\n    .addWhitelistedTerm('snigger'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'orgasm' })\n    .addPattern((0, Pattern_1.pattern) `[or]gasm`)\n    .addWhitelistedTerm('gasma'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'orgy' })\n    .addPattern((0, Pattern_1.pattern) `orgy`)\n    .addPattern((0, Pattern_1.pattern) `orgies`)\n    .addWhitelistedTerm('porgy'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'penis' })\n    .addPattern((0, Pattern_1.pattern) `pe[e]nis`)\n    .addPattern((0, Pattern_1.pattern) `|pnis`)\n    .addWhitelistedTerm('pen is'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'piss' }).addPattern((0, Pattern_1.pattern) `|piss`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'porn' })\n    .addPattern((0, Pattern_1.pattern) `|prn|`)\n    .addPattern((0, Pattern_1.pattern) `porn`)\n    .addWhitelistedTerm('p orna'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'prick' }).addPattern((0, Pattern_1.pattern) `|prick[s]|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'pussy' }).addPattern((0, Pattern_1.pattern) `p[u]ssy`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'rape' })\n    .addPattern((0, Pattern_1.pattern) `|rape`)\n    .addPattern((0, Pattern_1.pattern) `|rapis[s]t`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'retard' }).addPattern((0, Pattern_1.pattern) `retard`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'scat' }).addPattern((0, Pattern_1.pattern) `|s[s]cat|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'semen' }).addPattern((0, Pattern_1.pattern) `|s[s]e[e]me[e]n`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'sex' })\n    .addPattern((0, Pattern_1.pattern) `|s[s]e[e]x|`)\n    .addPattern((0, Pattern_1.pattern) `|s[s]e[e]xy|`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'shit' })\n    .addPattern((0, Pattern_1.pattern) `|shit`)\n    .addPattern((0, Pattern_1.pattern) `shit|`)\n    .addWhitelistedTerm('s hit')\n    .addWhitelistedTerm('sh it')\n    .addWhitelistedTerm('shi t')\n    .addWhitelistedTerm('shitake'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'slut' }).addPattern((0, Pattern_1.pattern) `s[s]lut`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'spastic' }).addPattern((0, Pattern_1.pattern) `|spastic`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'tit' })\n    .addPattern((0, Pattern_1.pattern) `|tit|`)\n    .addPattern((0, Pattern_1.pattern) `|tits|`)\n    .addPattern((0, Pattern_1.pattern) `|titt`)\n    .addPattern((0, Pattern_1.pattern) `|tiddies`)\n    .addPattern((0, Pattern_1.pattern) `|tities`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'tranny' }).addPattern((0, Pattern_1.pattern) `tranny`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'turd' })\n    .addPattern((0, Pattern_1.pattern) `|turd`)\n    .addWhitelistedTerm('turducken'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'twat' })\n    .addPattern((0, Pattern_1.pattern) `|twat`)\n    .addWhitelistedTerm('twattle'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'vagina' })\n    .addPattern((0, Pattern_1.pattern) `vagina`)\n    .addPattern((0, Pattern_1.pattern) `|v[?]gina`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'wank' }).addPattern((0, Pattern_1.pattern) `|wank`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'whore' })\n    .addPattern((0, Pattern_1.pattern) `|wh[o]re|`)\n    .addPattern((0, Pattern_1.pattern) `|who[o]res[s]|`)\n    .addWhitelistedTerm(\"who're\"));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.skipNonAlphabeticTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Creates a transformer that skips non-alphabetic characters (`a`-`z`,\n * `A`-`Z`). This is useful when matching text on patterns that are solely\n * comprised of alphabetic characters (the pattern `hello` does not match\n * `h.e.l.l.o` by default, but does with this transformer).\n *\n * **Warning**\n *\n * This transformation is not part of the default set of transformations, as\n * there are some known rough edges with false negatives; see\n * [#23](https://github.com/jo3-l/obscenity/issues/23) and\n * [#46](https://github.com/jo3-l/obscenity/issues/46) on the GitHub issue\n * tracker.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the end of the\n * transformer chain, if at all.\n *\n * @example\n * ```typescript\n * const transformer = skipNonAlphabeticTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction skipNonAlphabeticTransformer() {\n    return (0, Transformers_1.createSimpleTransformer)((c) => ((0, Char_1.isAlphabetic)(c) ? c : undefined));\n}\nexports.skipNonAlphabeticTransformer = skipNonAlphabeticTransformer;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./censor/BuiltinStrategies\"), exports);\n__exportStar(require(\"./censor/TextCensor\"), exports);\n__exportStar(require(\"./dataset/DataSet\"), exports);\n__exportStar(require(\"./matcher/regexp/RegExpMatcher\"), exports);\n__exportStar(require(\"./matcher/BlacklistedTerm\"), exports);\n__exportStar(require(\"./matcher/MatchPayload\"), exports);\n__exportStar(require(\"./matcher/Matcher\"), exports);\n__exportStar(require(\"./pattern/Nodes\"), exports);\n__exportStar(require(\"./pattern/ParserError\"), exports);\n__exportStar(require(\"./pattern/Pattern\"), exports);\n__exportStar(require(\"./preset/english\"), exports);\n__exportStar(require(\"./transformer/collapse-duplicates\"), exports);\n__exportStar(require(\"./transformer/remap-characters\"), exports);\n__exportStar(require(\"./transformer/resolve-confusables\"), exports);\n__exportStar(require(\"./transformer/resolve-leetspeak\"), exports);\n__exportStar(require(\"./transformer/skip-non-alphabetic\"), exports);\n__exportStar(require(\"./transformer/to-ascii-lowercase\"), exports);\n", "import mod from \"./index.js\";\n\nexport default mod;\nexport const DataSet = mod.DataSet;\nexport const ParserError = mod.ParserError;\nexport const PhraseBuilder = mod.PhraseBuilder;\nexport const RegExpMatcher = mod.RegExpMatcher;\nexport const SyntaxKind = mod.SyntaxKind;\nexport const TextCensor = mod.TextCensor;\nexport const assignIncrementingIds = mod.assignIncrementingIds;\nexport const asteriskCensorStrategy = mod.asteriskCensorStrategy;\nexport const collapseDuplicatesTransformer = mod.collapseDuplicatesTransformer;\nexport const compareMatchByPositionAndId = mod.compareMatchByPositionAndId;\nexport const englishDataset = mod.englishDataset;\nexport const englishRecommendedBlacklistMatcherTransformers = mod.englishRecommendedBlacklistMatcherTransformers;\nexport const englishRecommendedTransformers = mod.englishRecommendedTransformers;\nexport const englishRecommendedWhitelistMatcherTransformers = mod.englishRecommendedWhitelistMatcherTransformers;\nexport const fixedCharCensorStrategy = mod.fixedCharCensorStrategy;\nexport const fixedPhraseCensorStrategy = mod.fixedPhraseCensorStrategy;\nexport const grawlixCensorStrategy = mod.grawlixCensorStrategy;\nexport const keepEndCensorStrategy = mod.keepEndCensorStrategy;\nexport const keepStartCensorStrategy = mod.keepStartCensorStrategy;\nexport const parseRawPattern = mod.parseRawPattern;\nexport const pattern = mod.pattern;\nexport const randomCharFromSetCensorStrategy = mod.randomCharFromSetCensorStrategy;\nexport const remapCharactersTransformer = mod.remapCharactersTransformer;\nexport const resolveConfusablesTransformer = mod.resolveConfusablesTransformer;\nexport const resolveLeetSpeakTransformer = mod.resolveLeetSpeakTransformer;\nexport const skipNonAlphabeticTransformer = mod.skipNonAlphabeticTransformer;\nexport const toAsciiLowerCaseTransformer = mod.toAsciiLowerCaseTransformer;\n"],
  "mappings": "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",
  "names": ["keepStartCensorStrategy", "keepEndCensorStrategy", "asteriskCensorStrategy", "fixedCharCensorStrategy", "grawlixCensorStrategy", "randomCharFromSetCensorStrategy", "fixedPhraseCensorStrategy", "compareMatchByPositionAndId", "TextCensor", "assignIncrementingIds", "pattern", "DataSet", "PhraseBuilder", "pattern", "SyntaxKind", "pattern", "RegExpMatcher", "ParserError", "pattern", "parseRawPattern", "collapseDuplicatesTransformer", "remapCharactersTransformer", "resolveConfusablesTransformer", "resolveLeetSpeakTransformer", "toAsciiLowerCaseTransformer", "skipNonAlphabeticTransformer", "exports", "mod"]
}
