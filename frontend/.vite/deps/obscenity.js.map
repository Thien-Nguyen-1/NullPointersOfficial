{
  "version": 3,
  "sources": ["../../node_modules/obscenity/dist/util/Char.js", "../../node_modules/obscenity/dist/censor/BuiltinStrategies.js", "../../node_modules/obscenity/dist/util/Interval.js", "../../node_modules/obscenity/dist/matcher/MatchPayload.js", "../../node_modules/obscenity/dist/censor/TextCensor.js", "../../node_modules/obscenity/dist/matcher/BlacklistedTerm.js", "../../node_modules/obscenity/dist/dataset/DataSet.js", "../../node_modules/obscenity/dist/pattern/Nodes.js", "../../node_modules/obscenity/dist/pattern/Util.js", "../../node_modules/obscenity/dist/transformer/TransformerSet.js", "../../node_modules/obscenity/dist/util/CharacterIterator.js", "../../node_modules/obscenity/dist/matcher/IntervalCollection.js", "../../node_modules/obscenity/dist/matcher/regexp/RegExpMatcher.js", "../../node_modules/obscenity/dist/matcher/Matcher.js", "../../node_modules/obscenity/dist/pattern/ParserError.js", "../../node_modules/obscenity/dist/pattern/Parser.js", "../../node_modules/obscenity/dist/pattern/Pattern.js", "../../node_modules/obscenity/dist/transformer/Transformers.js", "../../node_modules/obscenity/dist/transformer/collapse-duplicates/transformer.js", "../../node_modules/obscenity/dist/transformer/collapse-duplicates/index.js", "../../node_modules/obscenity/dist/transformer/remap-characters/index.js", "../../node_modules/obscenity/dist/transformer/resolve-confusables/confusables.js", "../../node_modules/obscenity/dist/transformer/resolve-confusables/index.js", "../../node_modules/obscenity/dist/transformer/resolve-leetspeak/dictionary.js", "../../node_modules/obscenity/dist/transformer/resolve-leetspeak/index.js", "../../node_modules/obscenity/dist/transformer/to-ascii-lowercase/index.js", "../../node_modules/obscenity/dist/preset/english.js", "../../node_modules/obscenity/dist/transformer/skip-non-alphabetic/index.js", "../../node_modules/obscenity/dist/index.js", "../../node_modules/obscenity/dist/index.mjs"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAndAssertSingleCodePoint = exports.invertCaseOfAlphabeticChar = exports.isUpperCase = exports.isLowerCase = exports.isAlphabetic = exports.isDigit = exports.isWordChar = exports.convertSurrogatePairToCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;\nfunction isHighSurrogate(char) {\n    return 55296 /* CharacterCode.HighSurrogateStart */ <= char && char <= 56319 /* CharacterCode.HighSurrogateEnd */;\n}\nexports.isHighSurrogate = isHighSurrogate;\nfunction isLowSurrogate(char) {\n    return 56320 /* CharacterCode.LowSurrogateStart */ <= char && char <= 57343 /* CharacterCode.LowSurrogateEnd */;\n}\nexports.isLowSurrogate = isLowSurrogate;\n// See https://unicodebook.readthedocs.io/unicode_encodings.html#utf-16-surrogate-pairs.\nfunction convertSurrogatePairToCodePoint(highSurrogate, lowSurrogate) {\n    return ((highSurrogate - 55296 /* CharacterCode.HighSurrogateStart */) * 0x400 +\n        lowSurrogate -\n        56320 /* CharacterCode.LowSurrogateStart */ +\n        0x10000);\n}\nexports.convertSurrogatePairToCodePoint = convertSurrogatePairToCodePoint;\nfunction isWordChar(char) {\n    return isDigit(char) || isAlphabetic(char);\n}\nexports.isWordChar = isWordChar;\nfunction isDigit(char) {\n    return 48 /* CharacterCode.Zero */ <= char && char <= 57 /* CharacterCode.Nine */;\n}\nexports.isDigit = isDigit;\nfunction isAlphabetic(char) {\n    return isLowerCase(char) || isUpperCase(char);\n}\nexports.isAlphabetic = isAlphabetic;\nfunction isLowerCase(char) {\n    return 97 /* CharacterCode.LowerA */ <= char && char <= 122 /* CharacterCode.LowerZ */;\n}\nexports.isLowerCase = isLowerCase;\nfunction isUpperCase(char) {\n    return 65 /* CharacterCode.UpperA */ <= char && char <= 90 /* CharacterCode.UpperZ */;\n}\nexports.isUpperCase = isUpperCase;\n// Input must be a lower-case or upper-case ASCII alphabet character.\nfunction invertCaseOfAlphabeticChar(char) {\n    return char ^ 0x20;\n}\nexports.invertCaseOfAlphabeticChar = invertCaseOfAlphabeticChar;\n// Asserts that the string is comprised of one and only one code point,\n// then returns said code point.\nfunction getAndAssertSingleCodePoint(str) {\n    if ([...str].length !== 1)\n        throw new RangeError(`Expected the input string to be one code point in length.`);\n    return str.codePointAt(0);\n}\nexports.getAndAssertSingleCodePoint = getAndAssertSingleCodePoint;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomCharFromSetCensorStrategy = exports.fixedCharCensorStrategy = exports.fixedPhraseCensorStrategy = exports.grawlixCensorStrategy = exports.asteriskCensorStrategy = exports.keepEndCensorStrategy = exports.keepStartCensorStrategy = void 0;\nconst Char_1 = require(\"../util/Char\");\n/**\n * A text censoring strategy that extends another strategy, adding the first\n * character matched at the start of the generated string.\n *\n * @example\n * ```typescript\n * const strategy = keepStartCensorStrategy(grawlixCensorStrategy());\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'f$@* you'\n * ```\n * @example\n * ```typescript\n * // Since keepEndCensorStrategy() returns another text censoring strategy, you can use it\n * // as the base strategy to pass to keepStartCensorStrategy().\n * const strategy = keepStartCensorStrategy(keepEndCensorStrategy(asteriskCensorStrategy()));\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'f**k you'\n * ```\n * @param baseStrategy - Strategy to extend. It will be used to produce the end of\n * the generated string.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction keepStartCensorStrategy(baseStrategy) {\n    return (ctx) => {\n        if (ctx.overlapsAtStart)\n            return baseStrategy(ctx);\n        const firstChar = String.fromCodePoint(ctx.input.codePointAt(ctx.startIndex));\n        return firstChar + baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 });\n    };\n}\nexports.keepStartCensorStrategy = keepStartCensorStrategy;\n/**\n * A text censoring strategy that extends another strategy, adding the last\n * character matched at the end of the generated string.\n *\n * @example\n * ```typescript\n * const strategy = keepEndCensorStrategy(asteriskCensorStrategy());\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '***k you'\n * ```\n * @param baseStrategy - Strategy to extend. It will be used to produce the start\n * of the generated string.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction keepEndCensorStrategy(baseStrategy) {\n    return (ctx) => {\n        if (ctx.overlapsAtEnd)\n            return baseStrategy(ctx);\n        const lastChar = String.fromCodePoint(ctx.input.codePointAt(ctx.endIndex));\n        return baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 }) + lastChar;\n    };\n}\nexports.keepEndCensorStrategy = keepEndCensorStrategy;\n/**\n * A text censoring strategy that generates strings made up of asterisks (`*`).\n *\n * @example\n * ```typescript\n * const strategy = asteriskCensorStrategy();\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '**** you'\n * ```\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction asteriskCensorStrategy() {\n    return fixedCharCensorStrategy('*');\n}\nexports.asteriskCensorStrategy = asteriskCensorStrategy;\n/**\n * A text censoring strategy that generates\n * [grawlix](https://www.merriam-webster.com/words-at-play/grawlix-symbols-swearing-comic-strips),\n * i.e. strings that contain the characters `%`, `@`, `$`, `&`, and `*`.\n *\n * @example\n * ```typescript\n * const strategy = grawlixCensorStrategy();\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '%@&* you'\n * ```\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction grawlixCensorStrategy() {\n    return randomCharFromSetCensorStrategy('%@$&*');\n}\nexports.grawlixCensorStrategy = grawlixCensorStrategy;\n/**\n * A text censoring strategy that returns a fixed string.\n *\n * @example\n * ```typescript\n * // The replacement phrase '' effectively removes all matched regions\n * // from the string.\n * const strategy = fixedPhraseCensorStrategy('');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: ' you'\n * ```\n * @example\n * ```typescript\n * const strategy = fixedPhraseCensorStrategy('fudge');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: 'fudge you'\n * ```\n * @param phrase - Replacement phrase to use.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction fixedPhraseCensorStrategy(phrase) {\n    return () => phrase;\n}\nexports.fixedPhraseCensorStrategy = fixedPhraseCensorStrategy;\n/**\n * A text censoring strategy that generates replacement strings that are made up\n * of the character given, repeated as many times as needed.\n *\n * @example\n * ```typescript\n * const strategy = fixedCharCensorStrategy('*');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you'\n * // After: '**** you'.\n * ```\n * @param char - String that represents the code point which should be used when\n * generating the replacement string. Must be exactly one code point in length.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction fixedCharCensorStrategy(char) {\n    // Make sure the input character is one code point in length.\n    (0, Char_1.getAndAssertSingleCodePoint)(char);\n    return (ctx) => char.repeat(ctx.matchLength);\n}\nexports.fixedCharCensorStrategy = fixedCharCensorStrategy;\n/**\n * A text censoring strategy that generates replacement strings made up of\n * random characters from the set of characters provided. The strings never\n * contain two of the same character in a row.\n *\n * @example\n * ```typescript\n * const strategy = randomCharFromSetCensorStrategy('$#!');\n * const censor = new TextCensor().setStrategy(strategy);\n * // Before: 'fuck you!'\n * // After: '!#$# you!'\n * ```\n * @param charset - Set of characters from which the replacement string should\n * be constructed. Must have at least two characters.\n * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].\n */\nfunction randomCharFromSetCensorStrategy(charset) {\n    const chars = [...charset];\n    if (chars.length < 2)\n        throw new Error('The character set passed must have at least 2 characters.');\n    return (ctx) => {\n        if (ctx.matchLength === 0)\n            return '';\n        let lastIdx = Math.floor(Math.random() * chars.length);\n        let censored = chars[lastIdx];\n        for (let i = 1; i < ctx.matchLength; i++) {\n            let idx = Math.floor(Math.random() * (chars.length - 1));\n            // Transform the distribution for idx from [0, len-1) to\n            // [0, lastIdx) ∪ (lastIdx, len) to exclude lastIdx while\n            // ensuring a uniform distribution of generated characters.\n            if (idx >= lastIdx)\n                idx++;\n            lastIdx = idx;\n            censored += chars[idx];\n        }\n        return censored;\n    };\n}\nexports.randomCharFromSetCensorStrategy = randomCharFromSetCensorStrategy;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compareIntervals = void 0;\nfunction compareIntervals(lowerBound0, upperBound0, lowerBound1, upperBound1) {\n    if (lowerBound0 < lowerBound1)\n        return -1;\n    if (lowerBound1 < lowerBound0)\n        return 1;\n    if (upperBound0 < upperBound1)\n        return -1;\n    if (upperBound1 < upperBound0)\n        return 1;\n    return 0;\n}\nexports.compareIntervals = compareIntervals;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compareMatchByPositionAndId = void 0;\nconst Interval_1 = require(\"../util/Interval\");\n/**\n * Compares two match payloads.\n *\n * If the first match payload's start index is less than the second's, `-1` is\n *   returned;\n * If the second match payload's start index is less than the first's, `1` is\n *   returned;\n * If the first match payload's end index is less than the second's, `-1` is\n *   returned;\n * If the second match payload's end index is less than the first's, `1` is\n *   returned;\n * If the first match payload's term ID is less than the second's, `-1` is\n *   returned;\n * If the first match payload's term ID is equal to the second's, `0` is\n *   returned;\n * Otherwise, `1` is returned.\n *\n * @param a - First match payload.\n * @param b - Second match payload.\n * @returns The result of the comparison: -1 if the first should sort lower than\n * the second, 0 if they are the same, and 1 if the second should sort lower\n * than the first.\n */\nfunction compareMatchByPositionAndId(a, b) {\n    const result = (0, Interval_1.compareIntervals)(a.startIndex, a.endIndex, b.startIndex, b.endIndex);\n    if (result !== 0)\n        return result;\n    return a.termId === b.termId ? 0 : a.termId < b.termId ? -1 : 1;\n}\nexports.compareMatchByPositionAndId = compareMatchByPositionAndId;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextCensor = void 0;\nconst MatchPayload_1 = require(\"../matcher/MatchPayload\");\nconst BuiltinStrategies_1 = require(\"./BuiltinStrategies\");\n/**\n * Censors regions of text matched by a [[Matcher]], supporting flexible\n * [[TextCensorStrategy | censoring strategies]].\n */\nclass TextCensor {\n    constructor() {\n        this.strategy = (0, BuiltinStrategies_1.grawlixCensorStrategy)();\n    }\n    /**\n     * Sets the censoring strategy, which is responsible for generating\n     * replacement text for regions of the text that should be censored.\n     *\n     * The default censoring strategy is the [[grawlixCensorStrategy]],\n     * generating text like `$%@*`. There are several other built-in strategies\n     * available:\n     * - [[keepStartCensorStrategy]] - extends another strategy and keeps the\n     *   first character matched, e.g. `f***`.\n     * - [[keepEndCensorStrategy]] - extends another strategy and keeps the last\n     *   character matched, e.g. `***k`.\n     * - [[asteriskCensorStrategy]] - replaces the text with asterisks, e.g.\n     *   `****`.\n     * - [[grawlixCensorStrategy]] - the default strategy, discussed earlier.\n     *\n     * Note that since censoring strategies are just functions (see the\n     * documentation for [[TextCensorStrategy]]), it is relatively simple to\n     * create your own.\n     *\n     * To ease creation of common censoring strategies, we provide a number of\n     * utility functions:\n     * - [[fixedPhraseCensorStrategy]] - generates a fixed phrase, e.g. `fudge`.\n     * - [[fixedCharCensorStrategy]] - generates replacement strings constructed\n     *   from the character given, repeated as many times as needed.\n     * - [[randomCharFromSetCensorStrategy]] - generates replacement strings\n     *   made up of random characters from the set of characters provided.\n     *\n     * @param strategy - Text censoring strategy to use.\n     */\n    setStrategy(strategy) {\n        this.strategy = strategy;\n        return this;\n    }\n    /**\n     * Applies the censoring strategy to the text, returning the censored text.\n     *\n     * **Overlapping regions**\n     *\n     * Overlapping regions are an annoying edge case to deal with when censoring\n     * text. There is no single best way to handle them, but the implementation\n     * of this method guarantees that overlapping regions will always be\n     * replaced, following the rules below:\n     *\n     * - Replacement text for matched regions will be generated in the order\n     *   specified by [[compareMatchByPositionAndId]];\n     * - When generating replacements for regions that overlap at the start with\n     *   some other region, the start index of the censor context passed to the\n     *   censoring strategy will be the end index of the first region, plus one.\n     *\n     * @param input - Input text.\n     * @param matches - A list of matches.\n     * @returns The censored text.\n     */\n    applyTo(input, matches) {\n        if (matches.length === 0)\n            return input;\n        const sorted = [...matches].sort(MatchPayload_1.compareMatchByPositionAndId);\n        let censored = '';\n        let lastIndex = 0; // end index of last match, plus one\n        for (let i = 0; i < sorted.length; i++) {\n            const match = sorted[i];\n            if (lastIndex > match.endIndex)\n                continue; // completely contained in the previous span\n            const overlapsAtStart = match.startIndex < lastIndex;\n            // Add the chunk of text between the end of the last match and the\n            // start of the current match.\n            if (!overlapsAtStart)\n                censored += input.slice(lastIndex, match.startIndex);\n            const actualStartIndex = Math.max(lastIndex, match.startIndex);\n            const overlapsAtEnd = i < sorted.length - 1 && // not the last match\n                match.endIndex >= sorted[i + 1].startIndex && // end index of this match and start index of next one overlap\n                match.endIndex < sorted[i + 1].endIndex; // doesn't completely contain next match\n            censored += this.strategy({ ...match, startIndex: actualStartIndex, input, overlapsAtStart, overlapsAtEnd });\n            lastIndex = match.endIndex + 1;\n        }\n        censored += input.slice(lastIndex);\n        return censored;\n    }\n}\nexports.TextCensor = TextCensor;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignIncrementingIds = void 0;\n/**\n * Assigns incrementing IDs to the patterns provided, starting with 0. It is\n * useful if you have a list of patterns to match against but don't care about\n * identifying which pattern matched.\n *\n * @example\n * ```typescript\n * const matcher = new RegExpMatcher({\n *  ...,\n *  blacklistedTerms: assignIncrementingIds([\n *      pattern`f?uck`,\n *      pattern`|shit|`,\n *  ]),\n * });\n * ```\n * @param patterns - List of parsed patterns.\n * @returns A list of blacklisted terms with valid IDs which can then be passed\n * to the [[RegExpMatcher]].\n */\nfunction assignIncrementingIds(patterns) {\n    let currentId = 0;\n    return patterns.map((pattern) => ({ id: currentId++, pattern }));\n}\nexports.assignIncrementingIds = assignIncrementingIds;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PhraseBuilder = exports.DataSet = void 0;\nconst BlacklistedTerm_1 = require(\"../matcher/BlacklistedTerm\");\n/**\n * Holds phrases (groups of patterns and whitelisted terms), optionally\n * associating metadata with them.\n *\n * @typeParam MetadataType - Metadata type for phrases. Note that the metadata\n * type is implicitly nullable.\n */\nclass DataSet {\n    constructor() {\n        this.containers = [];\n        this.patternCount = 0;\n        this.patternIdToPhraseContainer = new Map(); // pattern ID => index of its container\n    }\n    /**\n     * Adds all the phrases from the dataset provided to this one.\n     *\n     * @example\n     * ```typescript\n     * const customDataset = new DataSet().addAll(englishDataset);\n     * ```\n     * @param other - Other dataset.\n     */\n    addAll(other) {\n        for (const container of other.containers)\n            this.registerContainer(container);\n        return this;\n    }\n    /**\n     * Removes phrases that match the predicate given.\n     *\n     * @example\n     * ```typescript\n     * const customDataset = new DataSet<{ originalWord: string }>()\n     * \t.addAll(englishDataset)\n     * \t.removePhrasesIf((phrase) => phrase.metadata.originalWord === 'fuck');\n     * ```\n     * @param predicate - A predicate that determines whether or not a phrase should be removed.\n     * Return `true` to remove, `false` to keep.\n     */\n    removePhrasesIf(predicate) {\n        // Clear the internal state, then gradually rebuild it by adding the\n        // containers that should be kept.\n        this.patternCount = 0;\n        this.patternIdToPhraseContainer.clear();\n        const containers = this.containers.splice(0);\n        for (const container of containers) {\n            const remove = predicate(container);\n            if (!remove)\n                this.registerContainer(container);\n        }\n        return this;\n    }\n    /**\n     * Adds a phrase to this dataset.\n     *\n     * @example\n     * ```typescript\n     * const data = new DataSet<{ originalWord: string }>()\n     * \t.addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fuck' })\n     * \t\t.addPattern(pattern`fuck`)\n     * \t\t.addPattern(pattern`f[?]ck`)\n     * \t\t.addWhitelistedTerm('Afck'))\n     * \t.build();\n     * ```\n     * @param fn - A function that takes a [[PhraseBuilder]], adds\n     * patterns/whitelisted terms/metadata to it, and returns it.\n     */\n    addPhrase(fn) {\n        const container = fn(new PhraseBuilder()).build();\n        this.registerContainer(container);\n        return this;\n    }\n    /**\n     * Retrieves the phrase metadata associated with a pattern and returns a\n     * copy of the match payload with said metadata attached to it.\n     *\n     * @example\n     * ```typescript\n     * const matches = matcher.getAllMatches(input);\n     * const matchesWithPhraseMetadata = matches.map((match) => dataset.getPayloadWithPhraseMetadata(match));\n     * // Now we can access the 'phraseMetadata' property:\n     * const phraseMetadata = matchesWithPhraseMetadata[0].phraseMetadata;\n     * ```\n     * @param payload - Original match payload.\n     */\n    getPayloadWithPhraseMetadata(payload) {\n        const offset = this.patternIdToPhraseContainer.get(payload.termId);\n        if (offset === undefined) {\n            throw new Error(`The pattern with ID ${payload.termId} does not exist in this dataset.`);\n        }\n        return {\n            ...payload,\n            phraseMetadata: this.containers[offset].metadata,\n        };\n    }\n    /**\n     * Returns the dataset in a format suitable for usage with the [[RegExpMatcher]].\n     *\n     * @example\n     * ```typescript\n     * // With the RegExpMatcher:\n     * const matcher = new RegExpMatcher({\n     * \t...dataset.build(),\n     * \t// additional options here\n     * });\n     * ```\n     */\n    build() {\n        return {\n            blacklistedTerms: (0, BlacklistedTerm_1.assignIncrementingIds)(this.containers.flatMap((p) => p.patterns)),\n            whitelistedTerms: this.containers.flatMap((p) => p.whitelistedTerms),\n        };\n    }\n    registerContainer(container) {\n        const offset = this.containers.push(container) - 1;\n        for (let i = 0, phraseId = this.patternCount; i < container.patterns.length; i++, phraseId++) {\n            this.patternIdToPhraseContainer.set(phraseId, offset);\n            this.patternCount++;\n        }\n    }\n}\nexports.DataSet = DataSet;\n/**\n * Builder for phrases.\n */\nclass PhraseBuilder {\n    constructor() {\n        this.patterns = [];\n        this.whitelistedTerms = [];\n    }\n    /**\n     * Associates a pattern with this phrase.\n     *\n     * @param pattern - Pattern to add.\n     */\n    addPattern(pattern) {\n        this.patterns.push(pattern);\n        return this;\n    }\n    /**\n     * Associates a whitelisted pattern with this phrase.\n     *\n     * @param term - Whitelisted term to add.\n     */\n    addWhitelistedTerm(term) {\n        this.whitelistedTerms.push(term);\n        return this;\n    }\n    /**\n     * Associates some metadata with this phrase.\n     *\n     * @param metadata - Metadata to use.\n     */\n    setMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the phrase, returning a [[PhraseContainer]] for use with the\n     * [[DataSet]].\n     */\n    build() {\n        return {\n            patterns: this.patterns,\n            whitelistedTerms: this.whitelistedTerms,\n            metadata: this.metadata,\n        };\n    }\n}\nexports.PhraseBuilder = PhraseBuilder;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyntaxKind = void 0;\n/**\n * An enumeration of the kinds of nodes there are.\n */\nvar SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"Optional\"] = 0] = \"Optional\";\n    SyntaxKind[SyntaxKind[\"Wildcard\"] = 1] = \"Wildcard\";\n    SyntaxKind[SyntaxKind[\"Literal\"] = 2] = \"Literal\";\n    SyntaxKind[SyntaxKind[\"BoundaryAssertion\"] = 3] = \"BoundaryAssertion\";\n})(SyntaxKind || (exports.SyntaxKind = SyntaxKind = {}));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRegExpStringForNode = exports.compilePatternToRegExp = exports.potentiallyMatchesEmptyString = void 0;\nconst Nodes_1 = require(\"./Nodes\");\nfunction potentiallyMatchesEmptyString(pattern) {\n    return pattern.nodes.every((node) => node.kind === Nodes_1.SyntaxKind.Optional);\n}\nexports.potentiallyMatchesEmptyString = potentiallyMatchesEmptyString;\nfunction compilePatternToRegExp(pattern) {\n    let regExpStr = '';\n    if (pattern.requireWordBoundaryAtStart)\n        regExpStr += '\\\\b';\n    for (const node of pattern.nodes)\n        regExpStr += getRegExpStringForNode(node);\n    if (pattern.requireWordBoundaryAtEnd)\n        regExpStr += `\\\\b`;\n    return new RegExp(regExpStr, 'gs');\n}\nexports.compilePatternToRegExp = compilePatternToRegExp;\nconst regExpSpecialChars = ['[', '.', '*', '+', '?', '^', '$', '{', '}', '(', ')', '|', '[', '\\\\', ']'].map((str) => str.charCodeAt(0));\nfunction getRegExpStringForNode(node) {\n    switch (node.kind) {\n        case Nodes_1.SyntaxKind.Literal: {\n            let str = '';\n            for (const char of node.chars) {\n                if (regExpSpecialChars.includes(char))\n                    str += '\\\\';\n                str += String.fromCodePoint(char);\n            }\n            return str;\n        }\n        case Nodes_1.SyntaxKind.Optional:\n            return `(?:${getRegExpStringForNode(node.childNode)})?`;\n        case Nodes_1.SyntaxKind.Wildcard:\n            return `.`;\n    }\n}\nexports.getRegExpStringForNode = getRegExpStringForNode;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransformerSet = void 0;\nclass TransformerSet {\n    constructor(transformers) {\n        this.transformers = transformers;\n        this.statefulTransformers = Array.from({ length: this.transformers.length });\n        for (let i = 0; i < this.transformers.length; i++) {\n            const transformer = this.transformers[i];\n            if (transformer.type === 1 /* TransformerType.Stateful */) {\n                this.statefulTransformers[i] = transformer.factory();\n            }\n        }\n    }\n    applyTo(char) {\n        let transformed = char;\n        for (let i = 0; i < this.transformers.length && transformed !== undefined; i++) {\n            const transformer = this.transformers[i];\n            if (transformer.type === 0 /* TransformerType.Simple */)\n                transformed = transformer.transform(transformed);\n            else\n                transformed = this.statefulTransformers[i].transform(transformed);\n        }\n        return transformed;\n    }\n    resetAll() {\n        for (let i = 0; i < this.transformers.length; i++) {\n            if (this.transformers[i].type === 1 /* TransformerType.Stateful */) {\n                this.statefulTransformers[i].reset();\n            }\n        }\n    }\n}\nexports.TransformerSet = TransformerSet;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CharacterIterator = void 0;\nconst Char_1 = require(\"./Char\");\nclass CharacterIterator {\n    constructor(input) {\n        this.lastPosition = -1;\n        this.currentPosition = 0;\n        this._lastWidth = 0;\n        this._input = input ?? '';\n    }\n    get input() {\n        return this._input;\n    }\n    setInput(input) {\n        this._input = input;\n        this.reset();\n        return this;\n    }\n    reset() {\n        this.lastPosition = -1;\n        this.currentPosition = 0;\n        this._lastWidth = 0;\n    }\n    next() {\n        if (this.done)\n            return { done: true, value: undefined };\n        this.lastPosition = this.currentPosition;\n        const char = this._input.charCodeAt(this.currentPosition++);\n        this._lastWidth = 1;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.done || !(0, Char_1.isHighSurrogate)(char))\n            return { done: false, value: char };\n        // Do we have a surrogate pair?\n        const next = this._input.charCodeAt(this.currentPosition);\n        if ((0, Char_1.isLowSurrogate)(next)) {\n            this._lastWidth++;\n            this.currentPosition++;\n            return { done: false, value: (0, Char_1.convertSurrogatePairToCodePoint)(char, next) };\n        }\n        return { done: false, value: char };\n    }\n    // Position of the iterator; equals the start index of the last character consumed.\n    // -1 if no characters were consumed yet.\n    get position() {\n        return this.lastPosition;\n    }\n    // Width of the last character consumed; 2 if it was a surrogate pair and 1 otherwise.\n    // 0 if no characters were consumed yet.\n    get lastWidth() {\n        return this._lastWidth;\n    }\n    get done() {\n        return this.currentPosition >= this._input.length;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nexports.CharacterIterator = CharacterIterator;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IntervalCollection = void 0;\nclass IntervalCollection {\n    constructor() {\n        this.dirty = false;\n        this.intervals = [];\n    }\n    insert(lowerBound, upperBound) {\n        this.intervals.push([lowerBound, upperBound]);\n        this.dirty = true;\n    }\n    query(lowerBound, upperBound) {\n        if (this.intervals.length === 0)\n            return false;\n        if (this.dirty) {\n            this.dirty = false;\n            // Sort by lower bound.\n            this.intervals.sort(\n            /* istanbul ignore next: not possible to write a robust test for this */\n            (a, b) => (a[0] < b[0] ? -1 : b[0] < a[0] ? 1 : 0));\n        }\n        for (const interval of this.intervals) {\n            // Since the intervals are sorted by lower bound, if we see an\n            // interval with a lower bound greater than the target, we can skip\n            // checking all the ones after it as it's impossible that they fully\n            // contain the target interval.\n            if (interval[0] > lowerBound)\n                break;\n            if (interval[0] <= lowerBound && upperBound <= interval[1])\n                return true;\n        }\n        return false;\n    }\n    values() {\n        return this.intervals.values();\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n}\nexports.IntervalCollection = IntervalCollection;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegExpMatcher = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Util_1 = require(\"../../pattern/Util\");\nconst TransformerSet_1 = require(\"../../transformer/TransformerSet\");\nconst CharacterIterator_1 = require(\"../../util/CharacterIterator\");\nconst IntervalCollection_1 = require(\"../IntervalCollection\");\nconst MatchPayload_1 = require(\"../MatchPayload\");\n/**\n * An implementation of the [[Matcher]] interface using regular expressions and\n * string searching methods.\n */\nclass RegExpMatcher {\n    /**\n     * Creates a new [[RegExpMatcher]] with the options given.\n     *\n     * @example\n     * ```typescript\n     * // Use the options provided by the English preset.\n     * const matcher = new RegExpMatcher({\n     * \t...englishDataset.build(),\n     * \t...englishRecommendedTransformers,\n     * });\n     * ```\n     * @example\n     * ```typescript\n     * // Simple matcher that only has blacklisted patterns.\n     * const matcher = new RegExpMatcher({\n     *  blacklistedTerms: assignIncrementingIds([\n     *      pattern`fuck`,\n     *      pattern`f?uck`, // wildcards (?)\n     *      pattern`bitch`,\n     *      pattern`b[i]tch` // optionals ([i] matches either \"i\" or \"\")\n     *  ]),\n     * });\n     *\n     * // Check whether some string matches any of the patterns.\n     * const doesMatch = matcher.hasMatch('fuck you bitch');\n     * ```\n     * @example\n     * ```typescript\n     * // A more advanced example, with transformers and whitelisted terms.\n     * const matcher = new RegExpMatcher({\n     *  blacklistedTerms: [\n     *      { id: 1, pattern: pattern`penis` },\n     *      { id: 2, pattern: pattern`fuck` },\n     *  ],\n     *  whitelistedTerms: ['pen is'],\n     *  blacklistMatcherTransformers: [\n     *      resolveConfusablesTransformer(), // '🅰' => 'a'\n     *      resolveLeetSpeakTransformer(), // '$' => 's'\n     *      foldAsciiCharCaseTransformer(), // case insensitive matching\n     *      skipNonAlphabeticTransformer(), // 'f.u...c.k' => 'fuck'\n     *      collapseDuplicatesTransformer(), // 'aaaa' => 'a'\n     *  ],\n     * });\n     *\n     * // Output all matches.\n     * console.log(matcher.getAllMatches('fu.....uuuuCK the pen is mightier than the sword!'));\n     * ```\n     * @param options - Options to use.\n     */\n    constructor({ blacklistedTerms, whitelistedTerms = [], blacklistMatcherTransformers = [], whitelistMatcherTransformers = [], }) {\n        this.blacklistedTerms = this.compileTerms(blacklistedTerms);\n        this.validateWhitelistedTerms(whitelistedTerms);\n        this.whitelistedTerms = whitelistedTerms;\n        this.blacklistMatcherTransformers = new TransformerSet_1.TransformerSet(blacklistMatcherTransformers);\n        this.whitelistMatcherTransformers = new TransformerSet_1.TransformerSet(whitelistMatcherTransformers);\n    }\n    getAllMatches(input, sorted = false) {\n        const whitelistedIntervals = this.getWhitelistedIntervals(input);\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.blacklistMatcherTransformers);\n        const matches = [];\n        for (const blacklistedTerm of this.blacklistedTerms) {\n            for (const match of transformed.matchAll(blacklistedTerm.regExp)) {\n                const origStartIndex = transformedToOrigIndex[match.index];\n                let origEndIndex = transformedToOrigIndex[match.index + match[0].length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                if (!whitelistedIntervals.query(origStartIndex, origEndIndex)) {\n                    matches.push({\n                        termId: blacklistedTerm.id,\n                        startIndex: origStartIndex,\n                        endIndex: origEndIndex,\n                        matchLength: [...match[0]].length,\n                    });\n                }\n            }\n        }\n        if (sorted)\n            matches.sort(MatchPayload_1.compareMatchByPositionAndId);\n        return matches;\n    }\n    hasMatch(input) {\n        const whitelistedIntervals = this.getWhitelistedIntervals(input);\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.blacklistMatcherTransformers);\n        for (const blacklistedTerm of this.blacklistedTerms) {\n            for (const match of transformed.matchAll(blacklistedTerm.regExp)) {\n                const origStartIndex = transformedToOrigIndex[match.index];\n                let origEndIndex = transformedToOrigIndex[match.index + match[0].length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                if (!whitelistedIntervals.query(origStartIndex, origEndIndex))\n                    return true;\n            }\n        }\n        return false;\n    }\n    getWhitelistedIntervals(input) {\n        const matches = new IntervalCollection_1.IntervalCollection();\n        const [transformedToOrigIndex, transformed] = this.applyTransformers(input, this.whitelistMatcherTransformers);\n        for (const whitelistedTerm of this.whitelistedTerms) {\n            let lastEnd = 0;\n            for (let startIndex = transformed.indexOf(whitelistedTerm, lastEnd); startIndex !== -1; startIndex = transformed.indexOf(whitelistedTerm, lastEnd)) {\n                let origEndIndex = transformedToOrigIndex[startIndex + whitelistedTerm.length - 1];\n                // End index is (unfortunately) inclusive, so adjust as necessary.\n                if (origEndIndex < input.length - 1 && // not the last character\n                    (0, Char_1.isHighSurrogate)(input.charCodeAt(origEndIndex)) && // character is a high surrogate\n                    (0, Char_1.isLowSurrogate)(input.charCodeAt(origEndIndex + 1)) // next character is a low surrogate\n                ) {\n                    origEndIndex++;\n                }\n                matches.insert(transformedToOrigIndex[startIndex], origEndIndex);\n                lastEnd = startIndex + whitelistedTerm.length;\n            }\n        }\n        return matches;\n    }\n    applyTransformers(input, transformers) {\n        const transformedToOrigIndex = [];\n        let transformed = '';\n        const iter = new CharacterIterator_1.CharacterIterator(input);\n        for (const char of iter) {\n            const transformedChar = transformers.applyTo(char);\n            if (transformedChar !== undefined) {\n                transformed += String.fromCodePoint(transformedChar);\n                while (transformedToOrigIndex.length < transformed.length)\n                    transformedToOrigIndex.push(iter.position);\n            }\n        }\n        transformers.resetAll();\n        return [transformedToOrigIndex, transformed];\n    }\n    compileTerms(terms) {\n        const compiled = [];\n        const seenIds = new Set();\n        for (const term of terms) {\n            if (seenIds.has(term.id))\n                throw new Error(`Duplicate blacklisted term ID ${term.id}.`);\n            if ((0, Util_1.potentiallyMatchesEmptyString)(term.pattern)) {\n                throw new Error(`Pattern with ID ${term.id} potentially matches empty string; this is unsupported.`);\n            }\n            compiled.push({\n                id: term.id,\n                regExp: (0, Util_1.compilePatternToRegExp)(term.pattern),\n            });\n            seenIds.add(term.id);\n        }\n        return compiled;\n    }\n    validateWhitelistedTerms(whitelist) {\n        if (whitelist.some((term) => term.length === 0)) {\n            throw new Error('Whitelisted term set contains empty string; this is unsupported.');\n        }\n    }\n}\nexports.RegExpMatcher = RegExpMatcher;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserError = void 0;\n/**\n * Custom error thrown by the parser when syntactical errors are detected.\n */\nclass ParserError extends Error {\n    constructor(message, line, column) {\n        super(`${line}:${column}: ${message}`);\n        this.name = 'ParserError';\n        this.line = line;\n        this.column = column;\n    }\n}\nexports.ParserError = ParserError;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst Char_1 = require(\"../util/Char\");\nconst CharacterIterator_1 = require(\"../util/CharacterIterator\");\nconst Nodes_1 = require(\"./Nodes\");\nconst ParserError_1 = require(\"./ParserError\");\nconst supportsEscaping = [\n    92 /* CharacterCode.Backslash */,\n    91 /* CharacterCode.LeftSquareBracket */,\n    93 /* CharacterCode.RightSquareBracket */,\n    63 /* CharacterCode.QuestionMark */,\n    124 /* CharacterCode.VerticalBar */,\n];\nconst supportsEscapingList = supportsEscaping.map((char) => `'${String.fromCodePoint(char)}'`).join(', ');\nconst eof = -1;\nclass Parser {\n    constructor() {\n        this.input = '';\n        this.line = 1;\n        this.column = 1;\n        this.position = 0;\n        this.lastColumn = 1;\n        this.lastWidth = 0;\n    }\n    parse(input) {\n        this.setInput(input);\n        const nodes = [];\n        const firstNode = this.nextNode();\n        const requireWordBoundaryAtStart = firstNode?.kind === Nodes_1.SyntaxKind.BoundaryAssertion;\n        if (firstNode && !requireWordBoundaryAtStart)\n            nodes.push(firstNode);\n        let requireWordBoundaryAtEnd = false;\n        while (!this.done) {\n            const pos = this.mark();\n            const node = this.nextNode();\n            if (node.kind !== Nodes_1.SyntaxKind.BoundaryAssertion) {\n                nodes.push(node);\n                continue;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!this.done) {\n                this.reportError('Boundary assertions are not supported in this position; they are only allowed at the start / end of the pattern.', pos);\n            }\n            requireWordBoundaryAtEnd = true;\n        }\n        return { requireWordBoundaryAtStart, requireWordBoundaryAtEnd, nodes };\n    }\n    setInput(input) {\n        this.input = input;\n        this.line = 1;\n        this.column = 1;\n        this.position = 0;\n        this.lastColumn = 1;\n        this.lastWidth = 0;\n        return this;\n    }\n    nextNode() {\n        switch (this.peek()) {\n            case eof:\n                return undefined;\n            case 91 /* CharacterCode.LeftSquareBracket */:\n                return this.parseOptional();\n            case 93 /* CharacterCode.RightSquareBracket */:\n                this.reportError(`Unexpected ']' with no corresponding '['.`);\n            // eslint-disable-next-line no-fallthrough\n            case 63 /* CharacterCode.QuestionMark */:\n                return this.parseWildcard();\n            case 124 /* CharacterCode.VerticalBar */:\n                return this.parseBoundaryAssertion();\n            default:\n                return this.parseLiteral();\n        }\n    }\n    get done() {\n        return this.position >= this.input.length;\n    }\n    // Optional ::= '[' Wildcard | Text ']'\n    parseOptional() {\n        const preOpenBracketPos = this.mark();\n        this.next(); // '['\n        const postOpenBracketPos = this.mark();\n        if (this.done)\n            this.reportError(\"Unexpected unclosed '['.\", preOpenBracketPos);\n        if (this.accept('['))\n            this.reportError('Unexpected nested optional node.', postOpenBracketPos);\n        const childNode = this.nextNode();\n        if (childNode.kind === Nodes_1.SyntaxKind.BoundaryAssertion) {\n            this.reportError('Boundary assertions are not supported in this position; they are only allowed at the start / end of the pattern.', postOpenBracketPos);\n        }\n        if (!this.accept(']'))\n            this.reportError(\"Unexpected unclosed '['.\");\n        return { kind: Nodes_1.SyntaxKind.Optional, childNode: childNode };\n    }\n    // Wildcard ::= '?'\n    parseWildcard() {\n        this.next(); // '?'\n        return { kind: Nodes_1.SyntaxKind.Wildcard };\n    }\n    // BoundaryAssertion ::= '|'\n    parseBoundaryAssertion() {\n        this.next(); // '|'\n        return { kind: Nodes_1.SyntaxKind.BoundaryAssertion };\n    }\n    // Literal              ::= (NON_SPECIAL | '\\' SUPPORTS_ESCAPING)+\n    // NON_SPECIAL         ::= _any character other than '\\', '?', '[', ']', or '|'_\n    // SUPPORTS_ESCAPING   ::= '\\' | '[' | ']' | '?' | '|'\n    parseLiteral() {\n        const chars = [];\n        while (!this.done) {\n            if (this.accept('[]?|')) {\n                this.backup();\n                break;\n            }\n            const next = this.next();\n            if (next === 92 /* CharacterCode.Backslash */) {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (this.done) {\n                    this.backup();\n                    this.reportError('Unexpected trailing backslash.');\n                }\n                // Can we escape the next character?\n                const escaped = this.next();\n                if (!supportsEscaping.includes(escaped)) {\n                    const repr = String.fromCodePoint(escaped);\n                    this.backup();\n                    this.reportError(`Cannot escape character '${repr}'; the only characters that can be escaped are the following: ${supportsEscapingList}.`);\n                }\n                chars.push(escaped);\n            }\n            else {\n                chars.push(next);\n            }\n        }\n        return { kind: Nodes_1.SyntaxKind.Literal, chars };\n    }\n    reportError(message, { line = this.line, column = this.column } = {}) {\n        throw new ParserError_1.ParserError(message, line, column);\n    }\n    // Marks the current position.\n    mark() {\n        return { line: this.line, column: this.column };\n    }\n    // Accepts any code point in the charset provided. Iff accepted, the character is consumed.\n    accept(charset) {\n        const next = this.next();\n        const iter = new CharacterIterator_1.CharacterIterator(charset);\n        for (const char of iter) {\n            if (char === next)\n                return true;\n        }\n        this.backup();\n        return false;\n    }\n    // Reads one code point from the input, without consuming it.\n    peek() {\n        const next = this.next();\n        this.backup();\n        return next;\n    }\n    // Consumes one code point from the input.\n    next() {\n        if (this.done)\n            return eof;\n        const char = this.input.charCodeAt(this.position++);\n        this.lastWidth = 1;\n        if (char === 10 /* CharacterCode.Newline */) {\n            this.lastColumn = this.column;\n            this.column = 1;\n            this.line++;\n            return char;\n        }\n        this.lastColumn = this.column++;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!(0, Char_1.isHighSurrogate)(char) || this.done)\n            return char;\n        // Do we have a surrogate pair?\n        const next = this.input.charCodeAt(this.position);\n        if ((0, Char_1.isLowSurrogate)(next)) {\n            this.position++;\n            this.lastWidth++;\n            return (0, Char_1.convertSurrogatePairToCodePoint)(char, next);\n        }\n        return char;\n    }\n    // Steps back one character; can only be called once per call to next().\n    backup() {\n        this.position -= this.lastWidth;\n        this.column = this.lastColumn;\n        // Adjust line count if needed.\n        if (this.lastWidth === 1 && this.input.charCodeAt(this.position) === 10 /* CharacterCode.Newline */) {\n            this.line--;\n        }\n    }\n}\nexports.Parser = Parser;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRawPattern = exports.pattern = void 0;\nconst Parser_1 = require(\"./Parser\");\nconst parser = new Parser_1.Parser();\n/**\n * Parses a pattern, which matches a set of strings; see the `Syntax` section\n * for details. This function is intended to be called as a [template\n * tag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).\n *\n * **Syntax**\n *\n * Generally speaking, in patterns, characters are interpreted literally. That\n * is, they match exactly what they are: `a` matches an `a`, `b` matches a `b`,\n * `;` matches a `;`, and so on.\n *\n * However, there are several constructs that have special meaning:\n *\n * - `[expr]` matches either the empty string or `expr` (an **optional\n *   expression**). `expr` may be a sequence of literal characters or a wildcard\n *   (see below).\n * - `?` matches any character (a **wildcard**).\n * - A `|` at the start or end of the pattern asserts position at a word\n *   boundary (a **word boundary assertion**). If `|` is at the start, it\n *   ensures that the match either starts at the start of the string or a non-\n *   word character preceding it; if it is at the end, it ensures that the match\n *   either ends at the end of the string or a non-word character follows it.\n *\n *   A word character is an lower-case or upper-case ASCII alphabet character or\n *   an ASCII digit.\n * - In a literal, a backslash may be used to **escape** one of the\n *   meta-characters mentioned above so that it does match literally: `\\\\[`\n *   matches `[`, and does not mark the start of an optional expression.\n *\n *   **Note about escapes**\n *\n *   As this function operates on raw strings, double-escaping backslashes is\n *   not necessary:\n *\n *   ```typescript\n *   // Use this:\n *   const parsed = pattern`hello \\[`;\n *   // Don't use this:\n *   const parsed = pattern`hello \\\\[`;\n *   ```\n *\n * **Examples**\n *\n * - `baz` matches `baz` exactly.\n *\n * - `b\\[ar` matches `b[ar` exactly.\n *\n * - `d?ude` matches `d`, then any character, then `ude`. All of the following\n *   strings are matched by this pattern:\n *   - `dyude`\n *   - `d;ude`\n *   - `d!ude`\n *\n * - `h[?]ello` matches either `h`, any character, then `ello` or the literal\n *   string `hello`. The set of strings it matches is equal to the union of the\n *   set of strings that the two patterns `hello` and `h?ello` match. All of the\n *   following strings are matched by this pattern:\n *   - `hello`\n *   - `h!ello`\n *   - `h;ello`\n *\n * - `|foobar|` asserts position at a word boundary, matches the literal string\n *   `foobar`, and asserts position at a word boundary:\n *   - `foobar` matches, as the start and end of string count as word\n *     boundaries;\n *   - `yofoobar` does _not_ match, as `f` is immediately preceded by a word\n *     character;\n *   - `hello foobar bye` matches, as `f` is immediately preceded by a non-word\n *     character, and `r` is immediately followed by a non-word character.\n *\n * **Grammar**\n *\n * ```\n * Pattern  ::= '['? Atom* ']'?\n * Atom     ::= Literal | Wildcard | Optional\n * Optional ::= '[' Literal | Wildcard ']'\n * Literal  ::= (NON_SPECIAL | '\\' SUPPORTS_ESCAPING)+\n *\n * NON_SPECIAL       ::= _any character other than '\\', '?', '[', ']', or '|'_\n * SUPPORTS_ESCAPING ::= '\\' | '[' | ']' | '?' | '|'\n * ```\n *\n * @example\n * ```typescript\n * const parsed = pattern`hello?`; // match \"hello\", then any character\n * ```\n * @example\n * ```typescript\n * const parsed = pattern`w[o]rld`; // match \"wrld\" or \"world\"\n * ```\n * @example\n * ```typescript\n * const parsed = pattern`my initials are \\[??\\]`; // match \"my initials are [\", then any two characters, then a \"]\"\n * ```\n * @returns The parsed pattern, which can then be used with the\n * [[RegExpMatcher]].\n * @throws [[ParserError]] if a syntactical error was detected while parsing the\n * pattern.\n * @see [[parseRawPattern]] if you want to parse a string into a pattern without\n * using a template tag.\n */\nfunction pattern(strings, ...expressions) {\n    let result = strings.raw[0];\n    for (const [i, expression] of expressions.entries()) {\n        result += expression;\n        result += strings.raw[i + 1];\n    }\n    return parser.parse(result);\n}\nexports.pattern = pattern;\n/**\n * Parses a string as a pattern directly.\n *\n * **Note**\n *\n * It is recommended to use the [[pattern | pattern template tag]] instead of\n * this function for literal patterns (i.e. ones without dynamic content).\n *\n * @param pattern - The string to parse.\n * @throws [[ParserError]] if a syntactical error was detected while parsing the\n * pattern.\n * @returns The parsed pattern, which can then be used with the\n * [[RegExpMatcher]].\n */\nfunction parseRawPattern(pattern) {\n    return parser.parse(pattern);\n}\nexports.parseRawPattern = parseRawPattern;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createStatefulTransformer = exports.createSimpleTransformer = void 0;\n/**\n * Creates a container holding the transformer function provided. Simple\n * transformers are suitable for stateless transformations, e.g., a\n * transformation that maps certain characters to others. For transformations\n * that need to keep around state, see `createStatefulTransformer`.\n *\n * @example\n * ```typescript\n * function lowercaseToUppercase(char) {\n *  return isLowercase(char) ? char - 32 : char;\n * }\n *\n * const transformer = createSimpleTransformer(lowercaseToUppercase);\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * function ignoreAllNonDigitChars(char) {\n *  return isDigit(char) ? char : undefined;\n * }\n *\n * const transformer = createSimpleTransformer(ignoreAllNonDigitChars);\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param transformer - Function that applies the transformation. It should\n * accept one argument, the input character, and return the transformed\n * character. A return value of `undefined` indicates that the character should\n * be ignored.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction createSimpleTransformer(transformer) {\n    return { type: 0 /* TransformerType.Simple */, transform: transformer };\n}\nexports.createSimpleTransformer = createSimpleTransformer;\n/**\n * Creates a container holding the stateful transformer. Stateful transformers\n * are objects which satisfy the `StatefulTransformer` interface. They are\n * suitable for transformations that require keeping around some state regarding\n * the characters previously transformed in the text.\n *\n * @example\n * ```typescript\n * class IgnoreDuplicateCharactersTransformer implements StatefulTransformer {\n *  private lastChar = -1;\n *\n *  public transform(char: number) {\n *      if (char === this.lastChar) return undefined;\n *      this.lastChar = char;\n *      return char;\n *  }\n *\n *  public reset() {\n *      this.lastChar = -1;\n *  }\n * }\n *\n * const transformer = createStatefulTransformer(() => new IgnoreDuplicateCharactersTransformer());\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param factory A function that returns an instance of the stateful\n * transformer.\n * @returns A container holding the stateful transformer, which can then be\n * passed to the [[RegExpMatcher]].\n */\nfunction createStatefulTransformer(factory) {\n    return { type: 1 /* TransformerType.Stateful */, factory };\n}\nexports.createStatefulTransformer = createStatefulTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapseDuplicatesTransformer = void 0;\nclass CollapseDuplicatesTransformer {\n    constructor({ defaultThreshold, customThresholds }) {\n        this.remaining = -1;\n        this.lastChar = -1;\n        this.defaultThreshold = defaultThreshold;\n        this.customThresholds = customThresholds;\n    }\n    transform(char) {\n        if (char === this.lastChar) {\n            return this.remaining-- > 0 ? char : undefined;\n        }\n        const threshold = this.customThresholds.get(char) ?? this.defaultThreshold;\n        this.remaining = threshold - 1;\n        this.lastChar = char;\n        return threshold > 0 ? char : undefined;\n    }\n    reset() {\n        this.remaining = -1;\n        this.lastChar = -1;\n    }\n}\nexports.CollapseDuplicatesTransformer = CollapseDuplicatesTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collapseDuplicatesTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\nconst transformer_1 = require(\"./transformer\");\n/**\n * Creates a transformer that collapses duplicate characters. This is useful for\n * detecting variants of patterns in which a character is repeated to bypass\n * detection.\n *\n * As an example, the pattern `hi` does not match `hhiii` by default, as the\n * frequency of the characters does not match. With this transformer, `hhiii`\n * would become `hi`, and would therefore match the pattern.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied after all other\n * transformers. Using it before other transformers may have the effect of not\n * catching duplicates of certain characters that were originally different but\n * became the same after a series of transformations.\n *\n * **Warning**\n *\n * This transformer should be used with caution, as while it can make certain\n * patterns match text that wouldn't have been matched before, it can also go\n * the other way. For example, the pattern `hello` clearly matches `hello`, but\n * with this transformer, by default, `hello` would become `helo` which does\n * _not_ match. In this cases, the `customThresholds` option can be used to\n * allow two `l`s in a row, making it leave `hello` unchanged.\n *\n * @example\n * ```typescript\n * // Collapse runs of the same character.\n * const transformer = collapseDuplicatesTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Collapse runs of characters other than 'a'.\n * const transformer = collapseDuplicatesTransformer({ customThresholds: new Map([['a', Infinity]]) });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param options - Options for the transformer.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction collapseDuplicatesTransformer({ defaultThreshold = 1, customThresholds = new Map(), } = {}) {\n    const map = createCharacterToThresholdMap(customThresholds);\n    return (0, Transformers_1.createStatefulTransformer)(() => new transformer_1.CollapseDuplicatesTransformer({ defaultThreshold, customThresholds: map }));\n}\nexports.collapseDuplicatesTransformer = collapseDuplicatesTransformer;\nfunction createCharacterToThresholdMap(customThresholds) {\n    const map = new Map();\n    for (const [str, threshold] of customThresholds) {\n        if (threshold < 0)\n            throw new RangeError('Expected all thresholds to be non-negative.');\n        const char = (0, Char_1.getAndAssertSingleCodePoint)(str);\n        map.set(char, threshold);\n    }\n    return map;\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.remapCharactersTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst CharacterIterator_1 = require(\"../../util/CharacterIterator\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Maps certain characters to other characters, leaving other characters\n * unchanged.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain.\n *\n * @example\n * ```typescript\n * // Transform 'a' to 'b'.\n * const transformer = remapCharactersTransformer({ 'b': 'a' });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Transform '🅱️' to 'b', and use a map instead of an object as the argument.\n * const transformer = remapCharactersTransformer(new Map([['b', '🅱️']]));\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @example\n * ```typescript\n * // Transform '🇴' and '0' to 'o'.\n * const transformer = remapCharactersTransformer({ o: '🇴0' });\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @param mapping - A map/object mapping certain characters to others.\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n * @see [[resolveConfusablesTransformer|  Transformer that handles confusable Unicode characters]]\n * @see [[resolveLeetSpeakTransformer | Transformer that handles leet-speak]]\n */\nfunction remapCharactersTransformer(mapping) {\n    const map = createOneToOneMap(mapping);\n    return (0, Transformers_1.createSimpleTransformer)((c) => map.get(c) ?? c);\n}\nexports.remapCharactersTransformer = remapCharactersTransformer;\nfunction createOneToOneMap(mapping) {\n    const map = new Map();\n    const iterable = mapping instanceof Map ? mapping.entries() : Object.entries(mapping);\n    for (const [original, equivalents] of iterable) {\n        const originalChar = (0, Char_1.getAndAssertSingleCodePoint)(original);\n        const iter = new CharacterIterator_1.CharacterIterator(equivalents);\n        for (const equivalent of iter)\n            map.set(equivalent, originalChar);\n    }\n    return map;\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.confusables = void 0;\n/**\n * Maps confusable Unicode characters to their normalized equivalents.\n *\n * @copyright\n * The data here is taken from the\n * [confusables](https://github.com/gc/confusables) library.\n *\n * ```text\n * # The MIT License (MIT)\n *\n * Copyright © 2019 https://github.com/gc/\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * ```\n */\nexports.confusables = new Map([\n    [' ', ' '],\n    ['0', '⓿'],\n    ['1', '⓵➊⑴¹𝟏𝟙１𝟷𝟣⒈𝟭1➀₁①❶⥠'],\n    ['2', '⓶⒉⑵➋ƻ²ᒿ𝟚２𝟮𝟤ᒾ𝟸Ƨ𝟐②ᴤ₂➁❷ᘝƨ'],\n    ['3', '³ⳌꞫ𝟑ℨ𝟛𝟯𝟥Ꝫ➌ЗȜ⓷ӠƷ３𝟹⑶⒊ʒʓǯǮƺ𝕴ᶾзᦡ➂③₃ᶚᴣᴟ❸ҘҙӬӡӭӟӞ'],\n    ['4', '➍ҶᏎ𝟜ҷ⓸ҸҹӴӵᶣ４чㄩ⁴➃₄④❹Ӌ⑷⒋'],\n    ['5', '𝟱⓹➎Ƽ𝟓𝟻𝟝𝟧５➄₅⑤⁵❺ƽ⑸⒌'],\n    ['6', 'ⳒᏮ𝟞𝟨𝟔➏⓺Ϭϭ⁶б６ᧈ⑥➅₆❻⑹⒍'],\n    ['7', '⓻𐓒➐７⁷⑦₇❼➆⑺⒎'],\n    ['8', '𐌚➑⓼８𝟠𝟪৪⁸₈𝟴➇⑧❽𝟾𝟖⑻⒏'],\n    ['9', 'ꝮⳊ⓽➒੧৭୨９𝟫𝟿𝟗⁹₉Գ➈⑨❾⑼⒐'],\n    ['A', '🄰Ꭿ𐊠𝕬𝜜𝐴ꓮᎪ𝚨ꭺ𝝖🅐Å∀🇦₳🅰𝒜𝘈𝐀𝔸дǺᗅⒶＡΑᾋᗩĂÃÅǍȀȂĀȺĄʌΛλƛᴀᴬДАልÄₐᕱªǞӒΆẠẢẦẨẬẮẰẲẴẶᾸᾹᾺΆᾼᾈᾉᾊᾌᾍᾎᾏἈἉἊἋἌἍἎἏḀȦǠӐÀÁÂẤẪ𝛢𝓐𝙰𝘼'],\n    ['a', '∂⍺ⓐձǟᵃᶏ⒜аɒａαȃȁคǎმäɑāɐąᾄẚạảǡầẵḁȧӑӓãåάὰάăẩằẳặᾀᾁᾂᾃᾅᾆᾰᾱᾲᾳᾴᶐᾶᾷἀἁἂἃἄἅἆἇᾇậắàáâấẫǻⱥ𝐚𝑎𝒂𝒶𝓪𝔞𝕒𝖆𝖺𝗮𝘢𝙖𝚊𝛂𝛼𝜶𝝰𝞪⍶'],\n    ['B', '𐌁𝑩𝕭🄱𐊡𝖡𝘽ꓐ𝗕𝘉𝜝𐊂𝚩𝐁𝛣𝝗𝐵𝙱𝔹Ᏼᏼ𝞑Ꞵ𝔅🅑฿𝓑ᗿᗾᗽ🅱ⒷＢвϐᗷƁ乃ßცჩ๖βɮБՅ๒ᙖʙᴮᵇጌḄℬΒВẞḂḆɃദᗹᗸᵝᙞᙟᙝᛒᙗᙘᴃ🇧'],\n    ['b', 'Ꮟ𝐛𝘣𝒷𝔟𝓫𝖇𝖻𝑏𝙗𝕓𝒃𝗯𝚋♭ᑳᒈｂᖚᕹᕺⓑḃḅҍъḇƃɓƅᖯƄЬᑲþƂ⒝ЪᶀᑿᒀᒂᒁᑾьƀҌѢѣᔎ'],\n    ['C', 'ᏟⲤ🄲ꓚ𐊢𐌂🅲𐐕🅒☾ČÇⒸＣↃƇᑕㄈ¢८↻ĈϾՇȻᙅᶜ⒞ĆҀĊ©टƆℂℭϹС匚ḈҪʗᑖᑡᑢᑣᑤᑥⅭ𝐂𝐶𝑪𝒞𝓒𝕮𝖢𝗖𝘊𝘾ᔍ'],\n    ['c', 'ⲥ𐐽ꮯĉｃⓒćčċçҁƈḉȼↄсርᴄϲҫ꒝ςɽϛ𝙲ᑦ᧚𝐜𝑐𝒄𝒸𝓬𝔠𝕔𝖈𝖼𝗰𝘤𝙘𝚌₵🇨ᥴᒼⅽ'],\n    ['D', 'Ꭰ🄳𝔡𝖉𝔻𝗗𝘋𝙳𝐷𝓓𝐃𝑫𝕯𝖣𝔇𝘿ꭰⅅ𝒟ꓓ🅳🅓ⒹＤƉᗪƊÐԺᴅᴰↁḊĐÞⅮᗞᑯĎḌḐḒḎᗫᗬᗟᗠᶛᴆ🇩'],\n    ['d', 'Ꮷꓒ𝓭ᵭ₫ԃⓓｄḋďḍḑḓḏđƌɖɗᵈ⒟ԁⅾᶁԀᑺᑻᑼᑽᒄᑰᑱᶑ𝕕𝖽𝑑𝘥𝒅𝙙𝐝𝗱𝚍ⅆ𝒹ʠժ'],\n    ['E', 'ꭼ🄴𝙀𝔼𐊆𝚬ꓰ𝝚𝞔𝓔𝑬𝗘🅴🅔ⒺΈＥƎἝᕮƐモЄᴇᴱᵉÉ乇ЁɆꂅ€ÈℰΕЕⴹᎬĒĔĖĘĚÊËԐỀẾỄỂẼḔḖẺȄȆẸỆȨḜḘḚἘἙἚἛἜῈΈӖὲέЀϵ🇪'],\n    ['e', '𝑒𝓮𝕖𝖊𝘦𝗲𝚎𝙚𝒆𝔢𝖾𝐞Ҿҿⓔｅ⒠èᧉéᶒêɘἔềếễ૯ǝєεēҽɛểẽḕḗĕėëẻěȅȇẹệȩɇₑęḝḙḛ℮еԑѐӗᥱёἐἑἒἓἕℯ'],\n    ['F', '🄵𐊇𝔉𝘍𐊥ꓝꞘ🅵🅕𝓕ⒻＦғҒᖴƑԲϝቻḞℱϜ₣🇫Ⅎ'],\n    ['f', '𝐟𝖋ⓕｆƒḟʃբᶠ⒡ſꊰʄ∱ᶂ𝘧'],\n    ['G', 'ꓖᏳ🄶Ꮐᏻ𝔾𝓖𝑮𝕲ꮐ𝒢𝙂𝖦𝙶𝔊𝐺𝐆🅶🅖ⒼＧɢƓʛĢᘜᴳǴĠԌĜḠĞǦǤԍ₲🇬⅁'],\n    ['g', 'ⓖｇǵĝḡğġǧģց૭ǥɠﻭﻮᵍ⒢ℊɡᧁ𝐠𝑔𝒈𝓰𝔤𝕘𝖌𝗀𝗴𝘨𝙜𝚐'],\n    ['H', '🄷𝜢ꓧ𝘏𝐻𝝜𝖧𐋏𝗛ꮋℍᎻℌⲎ𝑯𝞖🅷🅗ዞǶԋⒽＨĤᚺḢḦȞḤḨḪĦⱧҢңҤῊΉῌἨἩἪἫἭἮἯᾘᾙᾚᾛᾜᾝᾞᾟӉӈҥΉн卄♓𝓗ℋН𝐇𝙃𝙷ʜ𝛨Η𝚮ᕼӇᴴᵸ🇭'],\n    ['h', 'Һ⒣ђⓗｈĥḣḧȟḥḩḫẖħⱨհһከኩኪካɦℎ𝐡𝒉𝒽𝓱𝔥𝕙𝖍𝗁𝗵𝘩𝙝𝚑իʰᑋᗁɧんɥ'],\n    ['I', '🄸ЇꀤᏆ🅸🅘إﺇٳأﺃٲٵⒾＩ៸ÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗェエῘῙῚΊἸἹἺἻἼἽἾⅠΪΊɪᶦᑊᥣ𝛪𝐈𝙄𝙸𝓵𝙡𝐼ᴵ𝚰𝑰🇮'],\n    ['i', 'ⓘｉìíîĩīĭïḯỉǐȉȋịḭῐῑῒΐῖῗἰἱἲⅰⅼ∣ⵏ￨׀ا١۱ߊᛁἳἴἵɨіὶίᶖ𝔦𝚒𝝸𝗂𝐢𝕚𝖎𝗶𝘪𝙞ίⁱᵢ𝓲⒤'],\n    ['J', '🄹🅹🅙ⒿＪЈʝᒍנﾌĴʆวلյʖᴊᴶﻝጋɈⱼՂๅႱįᎫȷ丿ℐℑᒘᒙᒚᒛᒴᒵᒎᒏ🇯'],\n    ['j', 'ⓙｊϳʲ⒥ɉĵǰјڶᶨ𝒿𝘫𝗷𝑗𝙟𝔧𝒋𝗃𝓳𝕛𝚓𝖏𝐣'],\n    ['K', '𝗞🄺𝜥𝘒ꓗ𝙆𝕂Ⲕ𝔎𝛫Ꮶ𝞙𝒦🅺🅚₭ⓀＫĸḰќƘкҠκқҟӄʞҚКҡᴋᴷᵏ⒦ᛕЌጕḲΚKҜҝҞĶḴǨⱩϗӃ🇰'],\n    ['k', 'ⓚｋḱǩḳķḵƙⱪᶄ𝐤𝘬𝗄𝕜𝜅𝜘𝜿𝝒𝝹𝞌𝞳𝙠𝚔𝑘𝒌ϰ𝛋𝛞𝟆𝗸𝓴𝓀'],\n    ['L', '🄻𐐛Ⳑ𝑳𝙻𐑃𝓛ⳑꮮᏞꓡ🅻🅛ﺈ└ⓁւＬĿᒪ乚ՆʟꓶιԼᴸˡĹረḶₗΓլĻᄂⅬℒⱢᥧᥨᒻᒶᒷᶫﺎᒺᒹᒸᒫ⎳ㄥŁⱠﺄȽ🇱'],\n    ['l', 'ⓛｌŀĺľḷḹļӀℓḽḻłﾚɭƚɫⱡ|Ɩ⒧ʅǀוןΙІ｜ᶩӏ𝓘𝕀𝖨𝗜𝘐𝐥𝑙𝒍𝓁𝔩𝕝𝖑𝗅𝗹𝘭𝚕𝜤𝝞ı𝚤ɩι𝛊𝜄𝜾𝞲'],\n    ['M', '🄼𐌑𐊰ꓟⲘᎷ🅼🅜ⓂＭмṂ൱ᗰ州ᘻო๓♏ʍᙏᴍᴹᵐ⒨ḾМṀ௱ⅯℳΜϺᛖӍӎ𝐌𝑀𝑴𝓜𝔐𝕄𝕸𝖬𝗠𝘔𝙈𝙼𝚳𝛭𝜧𝝡𝞛🇲'],\n    ['m', '₥ᵯ𝖒𝐦𝗆𝔪𝕞𝓂ⓜｍനᙢ൩ḿṁⅿϻṃጠɱ៳ᶆ𝙢𝓶𝚖𝑚𝗺᧕᧗'],\n    ['N', '🄽ℕꓠ𝛮𝝢𝙽𝚴𝑵𝑁Ⲛ𝐍𝒩𝞜𝗡𝘕𝜨𝓝𝖭🅽₦🅝ЙЍⓃҋ៷ＮᴎɴƝᑎ几иՈռИהЛπᴺᶰŃ刀ክṄⁿÑПΝᴨոϖǸŇṆŅṊṈทŊӢӣӤӥћѝйᥢҊᴻ🇳'],\n    ['n', 'ח𝒏𝓷𝙣𝑛𝖓𝔫𝗇𝚗𝗻ᥒⓝήｎǹᴒńñᾗηṅňṇɲņṋṉղຖՌƞŋ⒩ภกɳпŉлԉȠἠἡῃդᾐᾑᾒᾓᾔᾕᾖῄῆῇῂἢἣἤἥἦἧὴήበቡቢባቤብቦȵ𝛈𝜂𝜼𝝶𝞰𝕟𝘯𝐧𝓃ᶇᵰᥥ∩'],\n    [\n        'O',\n        'ꄲ🄾𐊒𝟬ꓳⲞ𐐄𐊫𐓂𝞞🅞⍥◯ⵁ⊖０⊝𝝤Ѳϴ𝚶𝜪ѺӦӨӪΌʘ𝐎ǑÒŎÓÔÕȌȎㇿ❍ⓄＯὋロ❤૦⊕ØФԾΘƠᴼᵒ⒪ŐÖₒ¤◊Φ〇ΟОՕଠഠ௦סỒỐỖỔṌȬṎŌṐṒȮȰȪỎỜỚỠỞỢỌỘǪǬǾƟⵔ߀៰⍜⎔⎕⦰⦱⦲⦳⦴⦵⦶⦷⦸⦹⦺⦻⦼⦽⦾⦿⧀⧁⧂⧃ὈὉὊὌὍ',\n    ],\n    [\n        'o',\n        '𝚘𝛐𝗈𝞼ဝⲟ𝙤၀𐐬𝔬𐓪𝓸🇴⍤○ϙ🅾𝒪𝖮𝟢𝟶𝙾𝘰𝗼𝕠𝜊𝐨𝝾𝞸ᐤⓞѳ᧐ᥲðｏఠᦞՓòөӧóºōôǒȏŏồốȍỗổõσṍȭṏὄṑṓȯȫ๏ᴏőöѻоዐǭȱ০୦٥౦೦൦๐໐οօᴑ०੦ỏơờớỡởợọộǫøǿɵծὀὁόὸόὂὃὅ',\n    ],\n    ['P', '🄿ꓑ𝚸𝙿𝞠𝙋ꮲⲢ𝒫𝝦𝑃𝑷𝗣𝐏𐊕𝜬𝘗𝓟𝖯𝛲Ꮲ🅟Ҏ🅿ⓅＰƤᑭ尸Ṗրφքᴘᴾᵖ⒫ṔｱקРየᴩⱣℙΡῬᑸᑶᑷᑹᑬᑮ🇵₱'],\n    ['p', 'ҏ℗ⓟｐṕṗƥᵽῥρрƿǷῤ⍴𝓹𝓅𝐩𝑝𝒑𝔭𝕡𝖕𝗉𝗽𝘱𝙥𝚙𝛒𝝆𝞺𝜌𝞀'],\n    ['Q', '🅀🆀🅠ⓆＱℚⵕԚ𝐐𝑄𝑸𝒬𝓠𝚀𝘘𝙌𝖰𝕼𝔔𝗤🇶'],\n    ['q', 'ⓠｑգ⒬۹զᑫɋɊԛ𝗊𝑞𝘲𝕢𝚚𝒒𝖖𝐪𝔮𝓺𝙦'],\n    ['R', '℞℟ꭱᏒ𐒴ꮢᎡꓣ🆁🅡ⓇＲᴙȒʀᖇя尺ŔЯરƦᴿዪṚɌʁℛℜℝṘŘȐṜŖṞⱤ𝐑𝑅𝑹𝓡𝕽𝖱𝗥𝘙𝙍𝚁ᚱ🇷ᴚ'],\n    ['r', 'ⓡｒŕṙřȑȓṛṝŗгՐɾᥬṟɍʳ⒭ɼѓᴦᶉ𝐫𝑟𝒓𝓇𝓻𝔯𝕣𝖗𝗋𝗿𝘳𝙧ᵲґᵣ'],\n    ['S', '🅂ꇙ𝓢𝗦Ꮪ𝒮Ꮥ𝚂𝐒ꓢ𝖲𝔖𝙎𐊖𝕾𐐠𝘚𝕊𝑆𝑺🆂🅢ⓈＳṨŞֆՏȘˢ⒮ЅṠŠŚṤŜṦṢടᔕᔖᔢᔡᔣᔤ'],\n    ['s', 'ⓢꜱ𐑈ꮪｓśṥŝṡšṧʂṣṩѕşșȿᶊక𝐬𝑠𝒔𝓈𝓼𝔰𝕤𝖘𝗌𝘀𝘴𝙨𝚜ގ🇸'],\n    ['T', '🅃🆃𐌕𝚻𝛵𝕋𝕿𝑻𐊱𐊗𝖳𝙏🝨𝝩𝞣𝚃𝘛𝑇ꓔ⟙𝐓Ⲧ𝗧⊤𝔗Ꭲꭲ𝒯🅣⏇⏉ⓉＴтҬҭƬイŦԵτᴛᵀｲፕϮŤ⊥ƮΤТ下ṪṬȚŢṰṮ丅丁ᐪ𝛕𝜏𝝉𝞃𝞽𝓣ㄒ🇹ጥ'],\n    ['t', 'ⓣｔṫẗťṭțȶ੮էʇ†ţṱṯƭŧᵗ⒯ʈեƫ𝐭𝑡𝒕𝓉𝓽𝔱𝕥𝖙𝗍𝘁𝘵𝙩𝚝ナ'],\n    ['U', '🅄ꓴ𐓎꒤🆄🅤ŨŬŮᑗᑘǓǕǗǙⓊＵȖᑌ凵ƱմԱꓵЦŪՄƲᙀᵁᵘ⒰ŰપÜՍÙÚÛṸṺǛỦȔƯỪỨỮỬỰỤṲŲṶṴɄᥩᑧ∪ᘮ⋃𝐔𝑈𝑼𝒰𝓤𝔘𝕌𝖀𝖴𝗨𝘜𝙐𝚄🇺'],\n    ['u', 'ὺύⓤｕùũūừṷṹŭǖữᥙǚǜὗυΰนսʊǘǔúůᴜűųยûṻцሁüᵾᵤµʋủȕȗưứửựụṳṵʉῠῡῢΰῦῧὐὑϋύὒὓὔὕὖᥔ𝐮𝑢𝒖𝓊𝓾𝔲𝕦𝖚𝗎ᶙ'],\n    ['V', '🅅ꓦ𝑽𝖵𝘝Ꮩ𝚅𝙑𝐕🆅🅥ⓋＶᐯѴᵛ⒱۷ṾⅴⅤṼ٧ⴸѶᐺᐻ🇻𝓥'],\n    ['v', 'ሀⓥｖ𝜐𝝊ṽṿ౮งѵעᴠνטᵥѷ៴ᘁ𝙫𝚟𝛎𝜈𝝂𝝼𝞶𝘷𝘃𝓿'],\n    ['W', '🅆ᏔᎳ𝑾ꓪ𝒲𝘞🆆Ⓦ🅦ｗＷẂᾧᗯᥕ山ѠຟచաЩШώщฬшᙎᵂʷ⒲ฝሠẄԜẀŴẆẈധᘺѿᙡƜ₩🇼'],\n    ['w', 'ẁꮃẃⓦ⍵ŵẇẅẘẉⱳὼὠὡὢὣωὤὥὦὧῲῳῴῶῷⱲѡԝᴡώᾠᾡᾢᾣᾤᾥᾦɯ𝝕𝟉𝞏'],\n    ['X', '🞨🞩🞪🅇🞫🞬𐌗Ⲭꓫ𝖃𝞦𝘟𐊐𝚾𝝬𝜲Ꭓ𐌢𝖷𝑋𝕏𝔛𐊴𝗫🆇🅧❌Ⓧ𝓧ＸẊ᙭χㄨ𝒳ӾჯӼҳЖΧҲᵡˣ⒳אሸẌꊼⅩХ╳᙮ᕁᕽⅹᚷⵝ𝙓𝚇乂𝐗🇽'],\n    ['x', 'ⓧｘхẋ×ₓ⤫⤬⨯ẍᶍ𝙭ӽ𝘹𝐱𝚡⨰ﾒ𝔁'],\n    ['Y', 'Ⲩ𝚈𝑌𝗬𝐘ꓬ𝒀𝜰𐊲🆈🅨ⓎＹὛƳㄚʏ⅄ϔ￥¥ՎϓγץӲЧЎሃŸɎϤΥϒҮỲÝŶỸȲẎỶỴῨῩῪΎὙὝὟΫΎӮӰҰұ𝕐🇾'],\n    ['y', '🅈ᎽᎩⓨｙỳýŷỹȳẏÿỷуყẙỵƴɏᵞɣʸᶌү⒴ӳӱӯўУʎ'],\n    ['Z', '🅉ꓜ𝗭𝐙☡Ꮓ𝘡🆉🅩ⓏＺẔƵ乙ẐȤᶻ⒵ŹℤΖŻŽẒⱫ🇿'],\n    ['z', 'ꮓⓩｚźẑżžẓẕƶȥɀᴢጊʐⱬᶎʑᙆ'],\n]);\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveConfusablesTransformer = void 0;\nconst remap_characters_1 = require(\"../remap-characters\");\nconst confusables_1 = require(\"./confusables\");\n/**\n * Creates a transformer that maps confusable Unicode characters to their\n * normalized equivalent. For example, `⓵`, `➊`, and `⑴` become `1` when using\n * this transformer.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain.\n *\n * @example\n * ```typescript\n * const transformer = resolveConfusablesTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction resolveConfusablesTransformer() {\n    return (0, remap_characters_1.remapCharactersTransformer)(confusables_1.confusables);\n}\nexports.resolveConfusablesTransformer = resolveConfusablesTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dictionary = void 0;\nexports.dictionary = new Map([\n    ['a', '@4'],\n    ['c', '('],\n    ['e', '3'],\n    ['i', '1|!'],\n    ['g', '6'],\n    ['o', '0'],\n    ['s', '$5'],\n    ['t', '7'],\n    ['z', '2'],\n]);\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveLeetSpeakTransformer = void 0;\nconst remap_characters_1 = require(\"../remap-characters\");\nconst dictionary_1 = require(\"./dictionary\");\n/**\n * Creates a transformer that maps leet-speak characters to their normalized\n * equivalent. For example, `$` becomes `s` when using this transformer.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the start of the\n * transformer chain, but after similar transformers that map characters to\n * other characters, such as the [[resolveConfusablesTransformer | transformer\n * that resolves confusable Unicode characters]].\n *\n * @example\n * ```typescript\n * const transformer = resolveLeetSpeakTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction resolveLeetSpeakTransformer() {\n    return (0, remap_characters_1.remapCharactersTransformer)(dictionary_1.dictionary);\n}\nexports.resolveLeetSpeakTransformer = resolveLeetSpeakTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toAsciiLowerCaseTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Creates a transformer that changes all ASCII alphabet characters to\n * lower-case, leaving other characters unchanged.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the end of the\n * transformer chain. Using it before other transformers may have the effect of\n * making its changes useless as transformers applied after produce characters\n * of varying cases.\n *\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction toAsciiLowerCaseTransformer() {\n    return (0, Transformers_1.createSimpleTransformer)((c) => ((0, Char_1.isUpperCase)(c) ? (0, Char_1.invertCaseOfAlphabeticChar)(c) : c));\n}\nexports.toAsciiLowerCaseTransformer = toAsciiLowerCaseTransformer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.englishDataset = exports.englishRecommendedTransformers = exports.englishRecommendedWhitelistMatcherTransformers = exports.englishRecommendedBlacklistMatcherTransformers = void 0;\nconst DataSet_1 = require(\"../dataset/DataSet\");\nconst Pattern_1 = require(\"../pattern/Pattern\");\nconst collapse_duplicates_1 = require(\"../transformer/collapse-duplicates\");\nconst resolve_confusables_1 = require(\"../transformer/resolve-confusables\");\nconst resolve_leetspeak_1 = require(\"../transformer/resolve-leetspeak\");\nconst to_ascii_lowercase_1 = require(\"../transformer/to-ascii-lowercase\");\n/**\n * A set of transformers to be used when matching blacklisted patterns with the\n * [[englishDataset | english word dataset]].\n */\nexports.englishRecommendedBlacklistMatcherTransformers = [\n    (0, resolve_confusables_1.resolveConfusablesTransformer)(),\n    (0, resolve_leetspeak_1.resolveLeetSpeakTransformer)(),\n    (0, to_ascii_lowercase_1.toAsciiLowerCaseTransformer)(),\n    // See #23 and #46.\n    // skipNonAlphabeticTransformer(),\n    (0, collapse_duplicates_1.collapseDuplicatesTransformer)({\n        defaultThreshold: 1,\n        customThresholds: new Map([\n            ['b', 2],\n            ['e', 2],\n            ['o', 2],\n            ['l', 2],\n            ['s', 2],\n            ['g', 2], // ni_gg_er\n        ]),\n    }),\n];\n/**\n * A set of transformers to be used when matching whitelisted terms with the\n * [[englishDataset | english word dataset]].\n */\nexports.englishRecommendedWhitelistMatcherTransformers = [\n    (0, to_ascii_lowercase_1.toAsciiLowerCaseTransformer)(),\n    (0, collapse_duplicates_1.collapseDuplicatesTransformer)({\n        defaultThreshold: Number.POSITIVE_INFINITY,\n        customThresholds: new Map([[' ', 1]]), // collapse spaces\n    }),\n];\n/**\n * Recommended transformers to be used with the [[englishDataset | english word\n * dataset]] and the [[RegExpMatcher]].\n */\nexports.englishRecommendedTransformers = {\n    blacklistMatcherTransformers: exports.englishRecommendedBlacklistMatcherTransformers,\n    whitelistMatcherTransformers: exports.englishRecommendedWhitelistMatcherTransformers,\n};\n/**\n * A dataset of profane English words.\n *\n * @example\n * ```typescript\n * const matcher = new RegExpMatcher({\n * \t...englishDataset.build(),\n * \t...englishRecommendedTransformers,\n * });\n * ```\n * @example\n * ```typescript\n * // Extending the data-set by adding a new word and removing an existing one.\n * const myDataset = new DataSet()\n * \t.addAll(englishDataset)\n * \t.removePhrasesIf((phrase) => phrase.metadata.originalWord === 'vagina')\n * \t.addPhrase((phrase) => phrase.addPattern(pattern`|balls|`));\n * ```\n * @copyright\n * The words are taken from the [cuss](https://github.com/words/cuss) project,\n * with some modifications.\n *\n * ```text\n * (The MIT License)\n *\n * Copyright (c) 2016 Titus Wormer <tituswormer@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * ```\n */\nexports.englishDataset = new DataSet_1.DataSet()\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'abo' }).addPattern((0, Pattern_1.pattern) `|ab[b]o[s]|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'abeed' }).addPattern((0, Pattern_1.pattern) `ab[b]eed`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'africoon' }).addPattern((0, Pattern_1.pattern) `africoon`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'anal' })\n    .addPattern((0, Pattern_1.pattern) `|anal`)\n    .addWhitelistedTerm('analabos')\n    .addWhitelistedTerm('analagous')\n    .addWhitelistedTerm('analav')\n    .addWhitelistedTerm('analy')\n    .addWhitelistedTerm('analog')\n    .addWhitelistedTerm('an al')\n    .addPattern((0, Pattern_1.pattern) `danal`)\n    .addPattern((0, Pattern_1.pattern) `eanal`)\n    .addPattern((0, Pattern_1.pattern) `fanal`)\n    .addWhitelistedTerm('fan al')\n    .addPattern((0, Pattern_1.pattern) `ganal`)\n    .addWhitelistedTerm('gan al')\n    .addPattern((0, Pattern_1.pattern) `ianal`)\n    .addWhitelistedTerm('ian al')\n    .addPattern((0, Pattern_1.pattern) `janal`)\n    .addWhitelistedTerm('trojan al')\n    .addPattern((0, Pattern_1.pattern) `kanal`)\n    .addPattern((0, Pattern_1.pattern) `lanal`)\n    .addWhitelistedTerm('lan al')\n    .addPattern((0, Pattern_1.pattern) `lanal`)\n    .addWhitelistedTerm('lan al')\n    .addPattern((0, Pattern_1.pattern) `oanal|`)\n    .addPattern((0, Pattern_1.pattern) `panal`)\n    .addWhitelistedTerm('pan al')\n    .addPattern((0, Pattern_1.pattern) `qanal`)\n    .addPattern((0, Pattern_1.pattern) `ranal`)\n    .addPattern((0, Pattern_1.pattern) `sanal`)\n    .addPattern((0, Pattern_1.pattern) `tanal`)\n    .addWhitelistedTerm('tan al')\n    .addPattern((0, Pattern_1.pattern) `uanal`)\n    .addWhitelistedTerm('uan al')\n    .addPattern((0, Pattern_1.pattern) `vanal`)\n    .addWhitelistedTerm('van al')\n    .addPattern((0, Pattern_1.pattern) `wanal`)\n    .addPattern((0, Pattern_1.pattern) `xanal`)\n    .addWhitelistedTerm('texan al')\n    .addPattern((0, Pattern_1.pattern) `yanal`)\n    .addPattern((0, Pattern_1.pattern) `zanal`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'anus' })\n    .addPattern((0, Pattern_1.pattern) `anus`)\n    .addWhitelistedTerm('an us')\n    .addWhitelistedTerm('tetanus')\n    .addWhitelistedTerm('uranus')\n    .addWhitelistedTerm('janus')\n    .addWhitelistedTerm('manus'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'arabush' }).addPattern((0, Pattern_1.pattern) `arab[b]ush`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'arse' })\n    .addPattern((0, Pattern_1.pattern) `|ars[s]e`)\n    .addWhitelistedTerm('arsen'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'ass' })\n    .addPattern((0, Pattern_1.pattern) `|ass`)\n    .addWhitelistedTerm('assa')\n    .addWhitelistedTerm('assem')\n    .addWhitelistedTerm('assen')\n    .addWhitelistedTerm('asser')\n    .addWhitelistedTerm('asset')\n    .addWhitelistedTerm('assev')\n    .addWhitelistedTerm('assi')\n    .addWhitelistedTerm('assoc')\n    .addWhitelistedTerm('assoi')\n    .addWhitelistedTerm('assu'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bastard' }).addPattern((0, Pattern_1.pattern) `bas[s]tard`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bestiality' }).addPattern((0, Pattern_1.pattern) `be[e][a]s[s]tial`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'bitch' })\n    .addPattern((0, Pattern_1.pattern) `bitch`)\n    .addPattern((0, Pattern_1.pattern) `bich|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'blowjob' }).addPattern((0, Pattern_1.pattern) `b[b]l[l][o]wj[o]b`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'bollocks' }).addPattern((0, Pattern_1.pattern) `bol[l]ock`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'boob' }).addPattern((0, Pattern_1.pattern) `boob`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'boonga' })\n    .addPattern((0, Pattern_1.pattern) `boonga`)\n    .addWhitelistedTerm('baboon ga'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'buttplug' }).addPattern((0, Pattern_1.pattern) `buttplug`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'chingchong' }).addPattern((0, Pattern_1.pattern) `chingchong`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'chink' })\n    .addPattern((0, Pattern_1.pattern) `chink`)\n    .addWhitelistedTerm('chin k'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cock' })\n    .addPattern((0, Pattern_1.pattern) `|cock|`)\n    .addPattern((0, Pattern_1.pattern) `|cocks`)\n    .addPattern((0, Pattern_1.pattern) `|cockp`)\n    .addPattern((0, Pattern_1.pattern) `|cocke[e]|`)\n    .addWhitelistedTerm('cockney'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cuck' })\n    .addPattern((0, Pattern_1.pattern) `cuck`)\n    .addWhitelistedTerm('cuckoo'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cum' })\n    .addPattern((0, Pattern_1.pattern) `|cum`)\n    .addWhitelistedTerm('cumu')\n    .addWhitelistedTerm('cumb'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'cunt' })\n    .addPattern((0, Pattern_1.pattern) `|cunt`)\n    .addPattern((0, Pattern_1.pattern) `cunt|`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'deepthroat' })\n    .addPattern((0, Pattern_1.pattern) `deepthro[o]at`)\n    .addPattern((0, Pattern_1.pattern) `deepthro[o]t`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'dick' })\n    .addPattern((0, Pattern_1.pattern) `|dck|`)\n    .addPattern((0, Pattern_1.pattern) `dick`)\n    .addWhitelistedTerm('benedick')\n    .addWhitelistedTerm('dickens'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'dildo' }).addPattern((0, Pattern_1.pattern) `dildo`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'doggystyle' }).addPattern((0, Pattern_1.pattern) `d[o]g[g]ys[s]t[y]l[l]`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'double penetration' }).addPattern((0, Pattern_1.pattern) `double penetra`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'dyke' })\n    .addPattern((0, Pattern_1.pattern) `dyke`)\n    .addWhitelistedTerm('van dyke'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'ejaculate' })\n    .addPattern((0, Pattern_1.pattern) `e[e]jacul`)\n    .addPattern((0, Pattern_1.pattern) `e[e]jakul`)\n    .addPattern((0, Pattern_1.pattern) `e[e]acul[l]ate`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'fag' })\n    .addPattern((0, Pattern_1.pattern) `|fag`)\n    .addPattern((0, Pattern_1.pattern) `fggot`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'felch' }).addPattern((0, Pattern_1.pattern) `fe[e]l[l]ch`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fellatio' }).addPattern((0, Pattern_1.pattern) `f[e][e]llat`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'finger bang' }).addPattern((0, Pattern_1.pattern) `fingerbang`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'fisting' }).addPattern((0, Pattern_1.pattern) `fistin`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'fuck' })\n    .addPattern((0, Pattern_1.pattern) `f[?]ck`)\n    .addPattern((0, Pattern_1.pattern) `|fk`)\n    .addPattern((0, Pattern_1.pattern) `|fu|`)\n    .addPattern((0, Pattern_1.pattern) `|fuk`)\n    .addWhitelistedTerm('fick')\n    .addWhitelistedTerm('kung-fu')\n    .addWhitelistedTerm('kung fu'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'gangbang' }).addPattern((0, Pattern_1.pattern) `g[?]ngbang`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'handjob' }).addPattern((0, Pattern_1.pattern) `h[?]ndjob`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'hentai' }).addPattern((0, Pattern_1.pattern) `h[e][e]ntai`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'hooker' }).addPattern((0, Pattern_1.pattern) `hooker`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'incest' }).addPattern((0, Pattern_1.pattern) `incest`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'jerk off' }).addPattern((0, Pattern_1.pattern) `jerkoff`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'jizz' }).addPattern((0, Pattern_1.pattern) `jizz`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'kike' }).addPattern((0, Pattern_1.pattern) `kike`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'lubejob' }).addPattern((0, Pattern_1.pattern) `lubejob`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'masturbate' })\n    .addPattern((0, Pattern_1.pattern) `m[?]sturbate`)\n    .addPattern((0, Pattern_1.pattern) `masterbate`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'negro' })\n    .addPattern((0, Pattern_1.pattern) `negro`)\n    .addWhitelistedTerm('montenegro')\n    .addWhitelistedTerm('negron')\n    .addWhitelistedTerm('stoneground')\n    .addWhitelistedTerm('winegrow'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'nigger' })\n    .addPattern((0, Pattern_1.pattern) `n[i]gger`)\n    .addPattern((0, Pattern_1.pattern) `n[i]gga`)\n    .addPattern((0, Pattern_1.pattern) `|nig|`)\n    .addPattern((0, Pattern_1.pattern) `|nigs|`)\n    .addWhitelistedTerm('snigger'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'orgasm' })\n    .addPattern((0, Pattern_1.pattern) `[or]gasm`)\n    .addWhitelistedTerm('gasma'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'orgy' })\n    .addPattern((0, Pattern_1.pattern) `orgy`)\n    .addPattern((0, Pattern_1.pattern) `orgies`)\n    .addWhitelistedTerm('porgy'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'penis' })\n    .addPattern((0, Pattern_1.pattern) `pe[e]nis`)\n    .addPattern((0, Pattern_1.pattern) `|pnis`)\n    .addWhitelistedTerm('pen is'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'piss' }).addPattern((0, Pattern_1.pattern) `|piss`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'porn' })\n    .addPattern((0, Pattern_1.pattern) `|prn|`)\n    .addPattern((0, Pattern_1.pattern) `porn`)\n    .addWhitelistedTerm('p orna'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'prick' }).addPattern((0, Pattern_1.pattern) `|prick[s]|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'pussy' }).addPattern((0, Pattern_1.pattern) `p[u]ssy`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'rape' })\n    .addPattern((0, Pattern_1.pattern) `|rape`)\n    .addPattern((0, Pattern_1.pattern) `|rapis[s]t`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'retard' }).addPattern((0, Pattern_1.pattern) `retard`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'scat' }).addPattern((0, Pattern_1.pattern) `|s[s]cat|`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'semen' }).addPattern((0, Pattern_1.pattern) `|s[s]e[e]me[e]n`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'sex' })\n    .addPattern((0, Pattern_1.pattern) `|s[s]e[e]x|`)\n    .addPattern((0, Pattern_1.pattern) `|s[s]e[e]xy|`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'shit' })\n    .addPattern((0, Pattern_1.pattern) `|shit`)\n    .addPattern((0, Pattern_1.pattern) `shit|`)\n    .addWhitelistedTerm('s hit')\n    .addWhitelistedTerm('sh it')\n    .addWhitelistedTerm('shi t')\n    .addWhitelistedTerm('shitake'))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'slut' }).addPattern((0, Pattern_1.pattern) `s[s]lut`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'spastic' }).addPattern((0, Pattern_1.pattern) `|spastic`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'tit' })\n    .addPattern((0, Pattern_1.pattern) `|tit|`)\n    .addPattern((0, Pattern_1.pattern) `|tits|`)\n    .addPattern((0, Pattern_1.pattern) `|titt`)\n    .addPattern((0, Pattern_1.pattern) `|tiddies`)\n    .addPattern((0, Pattern_1.pattern) `|tities`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'tranny' }).addPattern((0, Pattern_1.pattern) `tranny`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'turd' })\n    .addPattern((0, Pattern_1.pattern) `|turd`)\n    .addWhitelistedTerm('turducken'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'twat' })\n    .addPattern((0, Pattern_1.pattern) `|twat`)\n    .addWhitelistedTerm('twattle'))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'vagina' })\n    .addPattern((0, Pattern_1.pattern) `vagina`)\n    .addPattern((0, Pattern_1.pattern) `|v[?]gina`))\n    .addPhrase((phrase) => phrase.setMetadata({ originalWord: 'wank' }).addPattern((0, Pattern_1.pattern) `|wank`))\n    .addPhrase((phrase) => phrase\n    .setMetadata({ originalWord: 'whore' })\n    .addPattern((0, Pattern_1.pattern) `|wh[o]re|`)\n    .addPattern((0, Pattern_1.pattern) `|who[o]res[s]|`)\n    .addWhitelistedTerm(\"who're\"));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.skipNonAlphabeticTransformer = void 0;\nconst Char_1 = require(\"../../util/Char\");\nconst Transformers_1 = require(\"../Transformers\");\n/**\n * Creates a transformer that skips non-alphabetic characters (`a`-`z`,\n * `A`-`Z`). This is useful when matching text on patterns that are solely\n * comprised of alphabetic characters (the pattern `hello` does not match\n * `h.e.l.l.o` by default, but does with this transformer).\n *\n * **Warning**\n *\n * This transformation is not part of the default set of transformations, as\n * there are some known rough edges with false negatives; see\n * [#23](https://github.com/jo3-l/obscenity/issues/23) and\n * [#46](https://github.com/jo3-l/obscenity/issues/46) on the GitHub issue\n * tracker.\n *\n * **Application order**\n *\n * It is recommended that this transformer be applied near the end of the\n * transformer chain, if at all.\n *\n * @example\n * ```typescript\n * const transformer = skipNonAlphabeticTransformer();\n * const matcher = new RegExpMatcher({ ..., blacklistMatcherTransformers: [transformer] });\n * ```\n * @returns A container holding the transformer, which can then be passed to the\n * [[RegExpMatcher]].\n */\nfunction skipNonAlphabeticTransformer() {\n    return (0, Transformers_1.createSimpleTransformer)((c) => ((0, Char_1.isAlphabetic)(c) ? c : undefined));\n}\nexports.skipNonAlphabeticTransformer = skipNonAlphabeticTransformer;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./censor/BuiltinStrategies\"), exports);\n__exportStar(require(\"./censor/TextCensor\"), exports);\n__exportStar(require(\"./dataset/DataSet\"), exports);\n__exportStar(require(\"./matcher/regexp/RegExpMatcher\"), exports);\n__exportStar(require(\"./matcher/BlacklistedTerm\"), exports);\n__exportStar(require(\"./matcher/MatchPayload\"), exports);\n__exportStar(require(\"./matcher/Matcher\"), exports);\n__exportStar(require(\"./pattern/Nodes\"), exports);\n__exportStar(require(\"./pattern/ParserError\"), exports);\n__exportStar(require(\"./pattern/Pattern\"), exports);\n__exportStar(require(\"./preset/english\"), exports);\n__exportStar(require(\"./transformer/collapse-duplicates\"), exports);\n__exportStar(require(\"./transformer/remap-characters\"), exports);\n__exportStar(require(\"./transformer/resolve-confusables\"), exports);\n__exportStar(require(\"./transformer/resolve-leetspeak\"), exports);\n__exportStar(require(\"./transformer/skip-non-alphabetic\"), exports);\n__exportStar(require(\"./transformer/to-ascii-lowercase\"), exports);\n", "import mod from \"./index.js\";\n\nexport default mod;\nexport const DataSet = mod.DataSet;\nexport const ParserError = mod.ParserError;\nexport const PhraseBuilder = mod.PhraseBuilder;\nexport const RegExpMatcher = mod.RegExpMatcher;\nexport const SyntaxKind = mod.SyntaxKind;\nexport const TextCensor = mod.TextCensor;\nexport const assignIncrementingIds = mod.assignIncrementingIds;\nexport const asteriskCensorStrategy = mod.asteriskCensorStrategy;\nexport const collapseDuplicatesTransformer = mod.collapseDuplicatesTransformer;\nexport const compareMatchByPositionAndId = mod.compareMatchByPositionAndId;\nexport const englishDataset = mod.englishDataset;\nexport const englishRecommendedBlacklistMatcherTransformers = mod.englishRecommendedBlacklistMatcherTransformers;\nexport const englishRecommendedTransformers = mod.englishRecommendedTransformers;\nexport const englishRecommendedWhitelistMatcherTransformers = mod.englishRecommendedWhitelistMatcherTransformers;\nexport const fixedCharCensorStrategy = mod.fixedCharCensorStrategy;\nexport const fixedPhraseCensorStrategy = mod.fixedPhraseCensorStrategy;\nexport const grawlixCensorStrategy = mod.grawlixCensorStrategy;\nexport const keepEndCensorStrategy = mod.keepEndCensorStrategy;\nexport const keepStartCensorStrategy = mod.keepStartCensorStrategy;\nexport const parseRawPattern = mod.parseRawPattern;\nexport const pattern = mod.pattern;\nexport const randomCharFromSetCensorStrategy = mod.randomCharFromSetCensorStrategy;\nexport const remapCharactersTransformer = mod.remapCharactersTransformer;\nexport const resolveConfusablesTransformer = mod.resolveConfusablesTransformer;\nexport const resolveLeetSpeakTransformer = mod.resolveLeetSpeakTransformer;\nexport const skipNonAlphabeticTransformer = mod.skipNonAlphabeticTransformer;\nexport const toAsciiLowerCaseTransformer = mod.toAsciiLowerCaseTransformer;\n"],
  "mappings": "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",
  "names": ["keepStartCensorStrategy", "keepEndCensorStrategy", "asteriskCensorStrategy", "fixedCharCensorStrategy", "grawlixCensorStrategy", "randomCharFromSetCensorStrategy", "fixedPhraseCensorStrategy", "compareMatchByPositionAndId", "TextCensor", "assignIncrementingIds", "pattern", "DataSet", "PhraseBuilder", "pattern", "SyntaxKind", "pattern", "RegExpMatcher", "ParserError", "pattern", "parseRawPattern", "collapseDuplicatesTransformer", "remapCharactersTransformer", "resolveConfusablesTransformer", "resolveLeetSpeakTransformer", "toAsciiLowerCaseTransformer", "skipNonAlphabeticTransformer", "exports", "mod"]
}
